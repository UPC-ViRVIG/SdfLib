// Algorithm configuration
// #define USE_TRILINEAR_INTERPOLATION
// #define USE_TRICUBIC_INTERPOLATION
// #define TRICUBIC_GRADIENTS
// #define SPHERE_MARCHING
// #define SPHERE_MARCHING_SOLVER
// #define OCTREE_TRAVERSAL_AND_SH
// #define OCTREE_TRAVERSAL_AND_SOLVER

#define MAX_AO_ITERATIONS 8
#define NEWTON_ITER 1
#define HALLEY_ITER 1
#define M_PI 3.14159265358979323846

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform image2D outputTexture;

uniform vec3 startGridSize;

layout(std430, binding = 3) buffer octree
{
    uint octreeData[];
};

// #ifdef TRICUBIC_GRADIENTS
// layout(std430, binding = 2) buffer octreeTricubic
// {
//     uint octreeTricubicData[];
// };
// #endif

const uint isLeafMask = 1 << 31;
const uint isMarkedMask = 1 << 30;
const uint childrenIndexMask = ~(isLeafMask | isMarkedMask);

uint roundFloat(float a)
{
    return (a >= 0.5) ? 1 : 0;
}

uniform vec2 pixelToView;
uniform vec2 nearPlaneHalfSize;
uniform vec2 nearAndFarPlane;
uniform mat4 invViewModelMatrix;
uniform float distanceScale;
uniform float minBorderValue;
uniform float epsilon; // Could be removed

//Options
uniform int maxIterations; // Could be removed
uniform int maxShadowIterations; // Could be removed

uniform bool useAO;

uniform bool useShadows;
uniform bool useSoftShadows; // Could be removed

//Lighting
uniform int lightNumber;
uniform vec3 lightPos[4];
uniform float lightIntensity[4];
uniform vec3 lightColor[4];
uniform float lightRadius[4];

//Material
uniform float matMetallic;
uniform float matRoughness;
uniform vec3 matAlbedo;
uniform vec3 matF0;

/// --- Utils --- ///
float sphereSDF(vec3 samplePoint, float radius) {
    return length(samplePoint) - radius;
}

float opSmoothIntersection( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) + k*h*(1.0-h); 
}

mat4 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);

    return mat4(
        vec4(1, 0, 0, 0),
        vec4(0, c, -s, 0),
        vec4(0, s, c, 0),
        vec4(0, 0, 0, 1)
    );
}

mat4 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);

    return mat4(
        vec4(c, 0, s, 0),
        vec4(0, 1, 0, 0),
        vec4(-s, 0, c, 0),
        vec4(0, 0, 0, 1)
    );
}

mat4 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);

    return mat4(
        vec4(c, -s, 0, 0),
        vec4(s, c, 0, 0),
        vec4(0, 0, 1, 0),
        vec4(0, 0, 0, 1)
    );
}

vec3 rotate(vec3 p, vec3 rot) 
{
    mat4 rotX = inverse(rotateX(rot.x));
    mat4 rotY = inverse(rotateY(rot.y));
    mat4 rotZ = inverse(rotateZ(rot.z));

    return (rotZ * rotY * rotX * vec4(p, 1)).xyz;
}  

const float pos_infinity = uintBitsToFloat(0x7F800000);
const float neg_infinity = uintBitsToFloat(0xFF800000);

//Ray slab intersection
bool raySlabIntersection(vec3 bbmin, vec3 bbmax, vec3 o, vec3 d_inv, out float tmin, out float tmax) {
    
    tmin = neg_infinity;
    tmax = pos_infinity;

    //x
    float tx1 = (bbmin.x - o.x) * d_inv.x;
    float tx2 = (bbmax.x - o.x) * d_inv.x;

    tmin = max(tmin, min(tx1, tx2));
    tmax = min(tmax, max(tx1, tx2));

    //y
    float ty1 = (bbmin.y - o.y) * d_inv.y;
    float ty2 = (bbmax.y - o.y) * d_inv.y;

    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));

    //z
    float tz1 = (bbmin.z - o.z) * d_inv.z;
    float tz2 = (bbmax.z - o.z) * d_inv.z;

    tmin = max(tmin, min(tz1, tz2));
    tmax = min(tmax, max(tz1, tz2));

    return tmax >= tmin;
}

float rayLeafIntersection(vec3 bbmax, vec3 bbmin, vec3 o, vec3 d_inv) {
    float tx = (((d_inv.x > 0) ? bbmax.x : bbmin.x) - o.x) * d_inv.x;
    float ty = (((d_inv.y > 0) ? bbmax.y : bbmin.y) - o.y) * d_inv.y;
    float tz = (((d_inv.z > 0) ? bbmax.z : bbmin.z) - o.z) * d_inv.z;

    if (tx < 0) tx = 1e8;
    if (ty < 0) ty = 1e8;
    if (tz < 0) tz = 1e8;
    return min(tx, min(ty, tz));
}

// Light utils functions
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = M_PI * denom * denom;
	
    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
	
    return num / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);
	
    return ggx1 * ggx2;
}

/// --- Access to the sdfOctree --- ///
bool isOutsideGrid(vec3 point) 
{
    vec3 fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));

    return arrayPos.x < 0 || arrayPos.y < 0 || arrayPos.z < 0 ||
       arrayPos.x >= startGridSize.x || arrayPos.y >= startGridSize.y || arrayPos.z >= startGridSize.z;
}

uint getLeaf(vec3 point, out vec3 leafPos, out float leafSize, out vec3 fracPart) 
{
    fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));

    #ifdef SPHERE_MARCHING_SOLVER
    if(arrayPos.x < 0 || arrayPos.y < 0 || arrayPos.z < 0 ||
       arrayPos.x >= startGridSize.x || arrayPos.y >= startGridSize.y || arrayPos.z >= startGridSize.z)
    {
        return 0;
    }
    #endif

    fracPart = fract(fracPart);

    int index = arrayPos.z * int(startGridSize.y * startGridSize.x) +
                arrayPos.y * int(startGridSize.x) +
                arrayPos.x;
    uint currentNode = octreeData[index];

    leafSize = 1.0/startGridSize.x;
    leafPos = vec3(arrayPos)/startGridSize;
    while(!bool(currentNode & isLeafMask))
    {
        uvec3 childPos = uvec3(roundFloat(fracPart.x), roundFloat(fracPart.y), roundFloat(fracPart.z));
        uint childIdx = (childPos.z << 2) +
                        (childPos.y << 1) +
                         childPos.x;

        currentNode = octreeData[(currentNode & childrenIndexMask) + childIdx];
        fracPart = fract(2.0 * fracPart);
        leafSize *= 0.5;
        leafPos = leafPos + vec3(childPos) * leafSize;
    }

    return currentNode;
}

void getPolynomial(uint currentNode, out float array[8]) 
{
    uint vIndex = currentNode & childrenIndexMask;
    array[0] = uintBitsToFloat(octreeData[vIndex]);
    array[1] = uintBitsToFloat(octreeData[vIndex + 1]);
    array[2] = uintBitsToFloat(octreeData[vIndex + 2]);
    array[3] = uintBitsToFloat(octreeData[vIndex + 3]);
    array[4] = uintBitsToFloat(octreeData[vIndex + 4]);
    array[5] = uintBitsToFloat(octreeData[vIndex + 5]);
    array[6] = uintBitsToFloat(octreeData[vIndex + 6]);
    array[7] = uintBitsToFloat(octreeData[vIndex + 7]);
    return;
}

float evalNode(uint vIndex, vec3 fracPart)
{
#ifdef USE_TRILINEAR_INTERPOLATION
    float d00 = uintBitsToFloat(octreeData[vIndex]) * (1.0f - fracPart.x) +
                uintBitsToFloat(octreeData[vIndex + 1]) * fracPart.x;
    float d01 = uintBitsToFloat(octreeData[vIndex + 2]) * (1.0f - fracPart.x) +
                uintBitsToFloat(octreeData[vIndex + 3]) * fracPart.x;
    float d10 = uintBitsToFloat(octreeData[vIndex + 4]) * (1.0f - fracPart.x) +
                uintBitsToFloat(octreeData[vIndex + 5]) * fracPart.x;
    float d11 = uintBitsToFloat(octreeData[vIndex + 6]) * (1.0f - fracPart.x) +
                uintBitsToFloat(octreeData[vIndex + 7]) * fracPart.x;

    float d0 = d00 * (1.0f - fracPart.y) + d01 * fracPart.y;
    float d1 = d10 * (1.0f - fracPart.y) + d11 * fracPart.y;

    return d0 * (1.0f - fracPart.z) + d1 * fracPart.z;
#endif

#ifdef USE_TRICUBIC_INTERPOLATION
    return 0.0
         + uintBitsToFloat(octreeData[vIndex + 0]) + uintBitsToFloat(octreeData[vIndex + 1]) * fracPart[0] + uintBitsToFloat(octreeData[vIndex + 2]) * fracPart[0] * fracPart[0] + uintBitsToFloat(octreeData[vIndex + 3]) * fracPart[0] * fracPart[0] * fracPart[0] + uintBitsToFloat(octreeData[vIndex + 4]) * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 5]) * fracPart[0] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 6]) * fracPart[0] * fracPart[0] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 7]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 8]) * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 9]) * fracPart[0] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 10]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 11]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 12]) * fracPart[1] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 13]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 14]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 15]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
         + uintBitsToFloat(octreeData[vIndex + 16]) * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 17]) * fracPart[0] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 18]) * fracPart[0] * fracPart[0] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 19]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 20]) * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[0] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 24]) * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 28]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
         + uintBitsToFloat(octreeData[vIndex + 32]) * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 33]) * fracPart[0] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 34]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 35]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 36]) * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 40]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 44]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
         + uintBitsToFloat(octreeData[vIndex + 48]) * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 49]) * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 50]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 51]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 52]) * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 56]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 60]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2];
#endif
}

float getDistance(vec3 point)
{
    vec3 fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));

    if(arrayPos.x < 0 || arrayPos.y < 0 || arrayPos.z < 0 ||
       arrayPos.x >= startGridSize.x || arrayPos.y >= startGridSize.y || arrayPos.z >= startGridSize.z)
    {
            vec3 q = abs(point - vec3(0.5)) - 0.5;
            return length(max(q, vec3(0.0)))/distanceScale + minBorderValue;
    }

    fracPart = fract(fracPart);

    int index = arrayPos.z * int(startGridSize.y * startGridSize.x) +
                arrayPos.y * int(startGridSize.x) +
                arrayPos.x;
    uint currentNode = octreeData[index];

    while(!bool(currentNode & isLeafMask))
    {
        uint childIdx = (roundFloat(fracPart.z) << 2) + 
                        (roundFloat(fracPart.y) << 1) + 
                         roundFloat(fracPart.x);

        currentNode = octreeData[(currentNode & childrenIndexMask) + childIdx];
        fracPart = fract(2.0 * fracPart);
    }

    uint vIndex = currentNode & childrenIndexMask;

    return evalNode(vIndex, fracPart);
}

vec3 getGradient(vec3 point)
{
    vec3 fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));
    fracPart = fract(fracPart);
    int index = arrayPos.z * int(startGridSize.y * startGridSize.x) +
                arrayPos.y * int(startGridSize.x) +
                arrayPos.x;
    uint currentNode = octreeData[index];

    while(!bool(currentNode & isLeafMask))
    {
        uint childIdx = (roundFloat(fracPart.z) << 2) + 
                        (roundFloat(fracPart.y) << 1) + 
                         roundFloat(fracPart.x);

        currentNode = octreeData[(currentNode & childrenIndexMask) + childIdx];
        fracPart = fract(2.0 * fracPart);
    }

    uint vIndex = currentNode & childrenIndexMask;

#ifdef USE_TRILINEAR_INTERPOLATION
    float gx = 0.0;
    {
        float d00 = uintBitsToFloat(octreeData[vIndex + 0]) * (1.0f - fracPart.y) +
                    uintBitsToFloat(octreeData[vIndex + 2]) * fracPart.y;
        float d01 = uintBitsToFloat(octreeData[vIndex + 1]) * (1.0f - fracPart.y) +
                    uintBitsToFloat(octreeData[vIndex + 3]) * fracPart.y;
        float d10 = uintBitsToFloat(octreeData[vIndex + 4]) * (1.0f - fracPart.y) +
                    uintBitsToFloat(octreeData[vIndex + 6]) * fracPart.y;
        float d11 = uintBitsToFloat(octreeData[vIndex + 5]) * (1.0f - fracPart.y) +
                    uintBitsToFloat(octreeData[vIndex + 7]) * fracPart.y;

        float d0 = d00 * (1.0f - fracPart.z) + d10 * fracPart.z;
        float d1 = d01 * (1.0f - fracPart.z) + d11 * fracPart.z;

        gx = d1 - d0;
    }

    float gy = 0.0;
    float gz = 0.0;
    {
        float d00 = uintBitsToFloat(octreeData[vIndex + 0]) * (1.0f - fracPart.x) +
                    uintBitsToFloat(octreeData[vIndex + 1]) * fracPart.x;
        float d01 = uintBitsToFloat(octreeData[vIndex + 2]) * (1.0f - fracPart.x) +
                    uintBitsToFloat(octreeData[vIndex + 3]) * fracPart.x;
        float d10 = uintBitsToFloat(octreeData[vIndex + 4]) * (1.0f - fracPart.x) +
                    uintBitsToFloat(octreeData[vIndex + 5]) * fracPart.x;
        float d11 = uintBitsToFloat(octreeData[vIndex + 6]) * (1.0f - fracPart.x) +
                    uintBitsToFloat(octreeData[vIndex + 7]) * fracPart.x;

        {
            float d0 = d00 * (1.0f - fracPart.z) + d10 * fracPart.z;
            float d1 = d01 * (1.0f - fracPart.z) + d11 * fracPart.z;

            gy = d1 - d0;
        }

        {
            float d0 = d00 * (1.0f - fracPart.y) + d01 * fracPart.y;
            float d1 = d10 * (1.0f - fracPart.y) + d11 * fracPart.y;

            gz = d1 - d0;
        }
    }

    return normalize(vec3(gx, gy, gz));
#endif

#ifdef USE_TRICUBIC_INTERPOLATION
        return normalize(vec3((1 * uintBitsToFloat(octreeData[vIndex + 1]) + 2 * uintBitsToFloat(octreeData[vIndex + 2]) * fracPart[0] + 3 * uintBitsToFloat(octreeData[vIndex + 3]) * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 5]) * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 6]) * fracPart[0] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 7]) * fracPart[0] * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 9]) * fracPart[1] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 10]) * fracPart[0] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 11]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 13]) * fracPart[1] * fracPart[1] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 14]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 15]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
            + 1 * uintBitsToFloat(octreeData[vIndex + 17]) * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 18]) * fracPart[0] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 19]) * fracPart[0] * fracPart[0] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
            + 1 * uintBitsToFloat(octreeData[vIndex + 33]) * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 34]) * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 35]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
            + 1 * uintBitsToFloat(octreeData[vIndex + 49]) * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 50]) * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 51]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2]),
            (1 * uintBitsToFloat(octreeData[vIndex + 4]) + 1 * uintBitsToFloat(octreeData[vIndex + 5]) * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 6]) * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 7]) * fracPart[0] * fracPart[0] * fracPart[0] + 2 * uintBitsToFloat(octreeData[vIndex + 8]) * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 9]) * fracPart[0] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 10]) * fracPart[0] * fracPart[0] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 11]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 12]) * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 13]) * fracPart[0] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 14]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 15]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1]
            + 1 * uintBitsToFloat(octreeData[vIndex + 20]) * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[0] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[0] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 24]) * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 28]) * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2]
            + 1 * uintBitsToFloat(octreeData[vIndex + 36]) * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[0] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 40]) * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 44]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
            + 1 * uintBitsToFloat(octreeData[vIndex + 52]) * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 56]) * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 60]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2]),
            (1 * uintBitsToFloat(octreeData[vIndex + 16]) + 1 * uintBitsToFloat(octreeData[vIndex + 17]) * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 18]) * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 19]) * fracPart[0] * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 20]) * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 24]) * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 28]) * fracPart[1] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
            + 2 * uintBitsToFloat(octreeData[vIndex + 32]) * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 33]) * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 34]) * fracPart[0] * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 35]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 36]) * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 40]) * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 44]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
            + 3 * uintBitsToFloat(octreeData[vIndex + 48]) * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 49]) * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 50]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 51]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 52]) * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 56]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 60]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2])
        ));
#endif
}

/// --- Scene --- ///
float map(vec3 pos)
{
    return distanceScale * getDistance(pos);
}

//Gradient of the scene
vec3 mapGradient(vec3 pos)
{
    // Get the exact gradient
    return getGradient(pos);

    // Get an approximation of the gradient
    // float dist = mapTri(pos);
    // return normalize(vec3(
    //     mapTri(pos + vec3(epsilon, 0, 0)) - dist,
    //     mapTri(pos + vec3(0, epsilon, 0)) - dist,
    //     mapTri(pos + vec3(0, 0, epsilon)) - dist
    // ));
}

/// --- Lighthing --- ///

#ifdef SPHERE_MARCHING
float getAO(vec3 pos, vec3 n)
{
    float occ = 0.0;
    float decay = 1.0;
    for(int i=0; i < MAX_AO_ITERATIONS; i++)
    {
        float h = 0.002 + 0.1 * float(i)/8.0;
        float d = map(pos + n * h);
        occ += max(h-d, 0.0);
        decay *= 0.8;
    }

    return min(1.0 - 1.5 * occ, 1.0);
}
#endif

// float hardshadow(in vec3 ro, in vec3 rd)
// {
//     vec3 result;
//     if (raymarchV3(ro, rd, result)) return 0.0;
//     return 1.0;
// }

// //Inigo Quilez improved soft shadow
// float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )
// {
//     float res = 1.0;
//     float t = mint;
//     for( int i=0; i<maxShadowIterations && t<maxt; i++ )
//     {
//         float h = distanceScale * getDistanceTricubic(ro + t*rd);
//         res = min( res, h/(w*t) );
//         t += clamp(h, 0.005, 0.50);
//         if( res<-1.0 || t>maxt ) break;
//     }
//     res = max(res,-1.0);
//     return 0.25*(1.0+res)*(1.0+res)*(2.0-res);
// }

float softshadowToPoint(vec3 startPos, vec3 dir, float tmax)
{
    float accDistance = 0.0;
    vec3 pos = startPos;
    float lastDistance = 1e8;
    uint it = 0;
    float res = 1.0;
    while (accDistance < tmax && it < maxIterations)
    {
        lastDistance = map(pos);
        if(lastDistance < epsilon) return 0.0;
        float dist = max(lastDistance, 0.0);
        accDistance += dist;
        res = min(res, dist/accDistance);
        pos += dir * dist;
        it += 1;
    }

    return res;
}

bool raycast(vec3 ro, vec3 rd, float far);

//hard shadows using v3
float shadow(vec3 ro, vec3 rd, float far, float coneAngle)
{
    #ifdef SPHERE_MARCHING
    return min(atan(softshadowToPoint(ro, rd, far)) / coneAngle, 1.0);
    #else
    return raycast(ro, rd, far) ? 0.0 : 1.0;
    #endif
}

vec3 mapColor(vec3 pos, vec3 cameraPos)
{
    //Approximate normal
    vec3 N = getGradient(pos);
    //View vector
    vec3 V = normalize(cameraPos - pos);

    // Object material
    float metallic, roughness;
    vec3 albedo, F0;
    metallic = matMetallic;
    roughness = matRoughness;
    albedo = matAlbedo;
    F0 = mix(matF0, albedo, metallic);
 
    vec3 Lo = vec3(0.0);

    // Directional lights
    for (int i = 0; i < lightNumber; i++) 
    {
        float distToLight = length(lightPos[i] - pos);
        vec3 L = normalize(lightPos[i] - pos);
        vec3 H = normalize(V + L);

        vec3 sunColor = lightIntensity[i] * lightColor[i];

        float coneAngle = atan(lightRadius[i]/distToLight);
        float solidAngle = M_PI * sin(coneAngle) * pow((lightRadius[i]/distToLight), 2.0);
        // float intensity = useShadows ? shadow(pos + epsilon * L, L, 0.005, distToLight, solidAngle) : 1.0f;
        float intensity = useShadows ? shadow(pos + + 0.0004 * N, L, distToLight, coneAngle) : 1.0f;
        vec3 radiance = sunColor * intensity;
        
        // Cook-torrance brdf
        float NDF = DistributionGGX(N, H, roughness);        
        float G = GeometrySmith(N, V, L, roughness);      
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);       
        
        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= 1.0 - metallic;	  
        
        vec3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + epsilon;
        vec3 specular = numerator / denominator;  
            
        // Add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);                
        Lo += (kD * albedo / M_PI + specular) * radiance * NdotL;
    }

    #if defined(SPHERE_MARCHING)
    vec3 ambient = useAO ? vec3(0.5) * albedo * getAO(pos, N) : vec3(0.5) * albedo; // Ambient light estimation
    #else
    vec3 ambient = vec3(0.5) * albedo; // Ambient light estimation
    #endif

    vec3 color = ambient + Lo;

    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2));  
   
    return color;
}

/// --- RAY MARCHING ALGORITHM --- ///

bool isInsideNode(vec3 p, vec3 cubeMin, vec3 cubeMax)
{
    bool insideX, insideY, insideZ;
    insideX = p.x >= cubeMin.x && p.x <= cubeMax.x;
    insideY = p.y >= cubeMin.y && p.y <= cubeMax.y;
    insideZ = p.z >= cubeMin.z && p.z <= cubeMax.z;
    return insideX && insideY && insideZ;
}

// The degree of the polynomials for which we compute roots
#ifdef USE_TRILINEAR_INTERPOLATION
#define MAX_DEGREE 3
#endif
#ifdef USE_TRICUBIC_INTERPOLATION
#define MAX_DEGREE 9
#endif
// When there are fewer intersections/roots than theoretically possible, some
// array entries are set to this value
#define NO_INTERSECTION 3.4e38


#if defined(OCTREE_TRAVERSAL_AND_SOLVER) || defined(SPHERE_MARCHING_SOLVER) || defined(OCTREE_TRAVERSAL_AND_SH)
// Searches a single root of a polynomial within a given interval.
// \param out_root The location of the found root.
// \param out_end_value The value of the given polynomial at end.
// \param poly Coefficients of the polynomial for which a root should be found.
//        Coefficient poly[i] is multiplied by x^i.
// \param begin The beginning of an interval where the polynomial is monotonic.
// \param end The end of said interval.
// \param begin_value The value of the given polynomial at begin.
// \param error_tolerance The error tolerance for the returned root location.
//        Typically the error will be much lower but in theory it can be
//        bigger.
// \return true if a root was found, false if no root exists.
bool newton_bisection(out float out_root, out float out_end_value,
    float poly[MAX_DEGREE + 1], float begin, float end,
    float begin_value, float error_tolerance)
{
    if (begin == end) {
        out_end_value = begin_value;
        return false;
    }
    // Evaluate the polynomial at the end of the interval
    out_end_value = poly[MAX_DEGREE];

    for (int i = MAX_DEGREE - 1; i != -1; --i)
        out_end_value = out_end_value * end + poly[i];
    // If the values at both ends have the same non-zero sign, there is no root
    if (begin_value * out_end_value > 0.0)
        return false;
    // Otherwise, we find the root iteratively using Newton bisection (with
    // bounded iteration count)
    float current = 0.5 * (begin + end);

    for (int i = 0; i != 90; ++i) {
        // Evaluate the polynomial and its derivative
        float value = poly[MAX_DEGREE] * current + poly[MAX_DEGREE - 1];
        float derivative = poly[MAX_DEGREE];

        for (int j = MAX_DEGREE - 2; j != -1; --j) {
            derivative = derivative * current + value;
            value = value * current + poly[j];
        }
        // Shorten the interval
        bool right = begin_value * value > 0.0;
        begin = right ? current : begin;
        end = right ? end : current;
        // Apply Newton's method
        float guess = current - value / derivative;
        // Pick a guess
        float middle = 0.5 * (begin + end);
        float next = (guess >= begin && guess <= end) ? guess : middle;
        // Move along or terminate
        bool done = abs(next - current) < error_tolerance;
        current = next;
        if (done)
            break;
    }
    out_root = current;
    return true;
}


// Finds all roots of the given polynomial in the interval [begin, end] and
// writes them to out_roots. Some entries will be NO_INTERSECTION but other
// than that the array is sorted. The last entry is always NO_INTERSECTION.
void find_roots(out float out_roots[MAX_DEGREE + 1], float poly[MAX_DEGREE + 1], float begin, float end) {
    float tolerance = (end - begin) * epsilon;
    // Construct the quadratic derivative of the polynomial. We divide each
    // derivative by the factorial of its order, such that the constant
    // coefficient can be copied directly from poly. That is a safeguard
    // against overflow and makes it easier to avoid spilling below. The
    // factors happen to be binomial coefficients then.
    float derivative[MAX_DEGREE + 1];
    derivative[0] = poly[MAX_DEGREE - 2];
    derivative[1] = float(MAX_DEGREE - 1) * poly[MAX_DEGREE - 1];
    derivative[2] = (0.5 * float((MAX_DEGREE - 1) * MAX_DEGREE)) * poly[MAX_DEGREE - 0];

    for (int i = 3; i != MAX_DEGREE + 1; ++i)
        derivative[i] = 0.0;
    // Compute its two roots using the quadratic formula
    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];
    if (discriminant >= 0.0) {
        float sqrt_discriminant = sqrt(discriminant);
        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));
        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);
        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);
        out_roots[MAX_DEGREE - 2] = min(root_0, root_1);
        out_roots[MAX_DEGREE - 1] = max(root_0, root_1);
    }
    else {
        // Indicate that the cubic derivative has a single root
        out_roots[MAX_DEGREE - 2] = begin;
        out_roots[MAX_DEGREE - 1] = begin;
    }
    // The last entry in the root array is set to end to make it easier to
    // iterate over relevant intervals, all untouched roots are set to begin
    out_roots[MAX_DEGREE] = end;

    for (int i = 0; i != MAX_DEGREE - 2; ++i)
        out_roots[i] = begin;
    // Work your way up to derivatives of higher degree until you reach the
    // polynomial itself. This implementation may seem peculiar: It always
    // treats the derivative as though it had degree MAX_DEGREE and it
    // constructs the derivatives in a contrived way. Changing that would
    // reduce the number of arithmetic instructions roughly by a factor of two.
    // However, it would also cause register spilling, which has a far more
    // negative impact on the overall run time. Profiling indicates that the
    // current implementation has no spilling whatsoever.

    for (int degree = 3; degree != MAX_DEGREE + 1; ++degree) {
        // Take the integral of the previous derivative (scaled such that the
        // constant coefficient can still be copied directly from poly)
        float prev_derivative_order = float(MAX_DEGREE + 1 - degree);

        for (int i = MAX_DEGREE; i != 0; --i)
            derivative[i] = derivative[i - 1] * (prev_derivative_order * (1.0 / float(i)));
        // Copy the constant coefficient without causing spilling. This part
        // would be harder if the derivative were not scaled the way it is.

        for (int i = 0; i != MAX_DEGREE - 2; ++i)
            derivative[0] = (degree == MAX_DEGREE - i) ? poly[i] : derivative[0];
        // Determine the value of this derivative at begin
        float begin_value = derivative[MAX_DEGREE];

        for (int i = MAX_DEGREE - 1; i != -1; --i)
            begin_value = begin_value * begin + derivative[i];
        // Iterate over the intervals where roots may be found

        for (int i = 0; i != MAX_DEGREE; ++i) {
            if (i < MAX_DEGREE - degree)
                continue;
            float current_begin = out_roots[i];
            float current_end = out_roots[i + 1];
            // Try to find a root
            float root;
            if (newton_bisection(root, begin_value, derivative, current_begin, current_end, begin_value, tolerance))
                out_roots[i] = root;
            else if (degree < MAX_DEGREE)
                // Create an empty interval for the next iteration
                out_roots[i] = out_roots[i - 1];
            else
                out_roots[i] = NO_INTERSECTION;
        }
    }
    // We no longer need this array entry
    out_roots[MAX_DEGREE] = NO_INTERSECTION;
}

bool solvePolynomialEquation(vec3 o, vec3 dir, uint leafNode, vec3 leafPos, float leafSize, out vec3 result)
{
    float t_res;
    vec3 p = (o - leafPos) / leafSize;
    vec3 v = dir / leafSize;

    float leaf_t_in, leaf_t_out;
    raySlabIntersection(vec3(0), vec3(1), p, 1/v, leaf_t_in, leaf_t_out);
    leaf_t_in = max(leaf_t_in, 0.0);
#ifdef USE_TRILINEAR_INTERPOLATION
    float[8] values;

    uint vIndex = leafNode & childrenIndexMask;
    values[0] = uintBitsToFloat(octreeData[vIndex]); // S000
    values[1] = uintBitsToFloat(octreeData[vIndex + 1]) - values[0]; // S100 - S000
    values[2] = uintBitsToFloat(octreeData[vIndex + 2]); // S010
    values[3] = uintBitsToFloat(octreeData[vIndex + 3]) - values[2] - values[1]; //S110 - S010 - values[1]
    values[2] = values[2] - values[0]; // S010 - S000
    values[4] = uintBitsToFloat(octreeData[vIndex + 4]); // S001
    values[5] = uintBitsToFloat(octreeData[vIndex + 5]) - values[4]; // S101 - S001 (a)
    values[6] = uintBitsToFloat(octreeData[vIndex + 6]); // S011
    values[7] = values[3] - uintBitsToFloat(octreeData[vIndex + 7]) + values[6] + values[5];
    values[6] = values[2] - values[6] + values[4];
    values[5] = values[1] - values[5];
    values[4] = values[0] - values[4];

    float[6] m;
    m[0] = p.x*p.y;
    m[1] = v.x*v.y;
    m[2] = p.x*v.y + p.y*v.x;
    m[3] = values[5]*p.z - values[1];
    m[4] = values[6]*p.z - values[2];
    m[5] = values[7]*p.z - values[3];

    float[4] eq;
    eq[0] = -(values[4]*p.z - values[0] + p.x * m[3] + p.y * m[4] + m[0] * m[5]);
    eq[1] = -(v.x * m[3] + v.y * m[4] + m[2] * m[5] + v.z * (values[4] + values[5] * p.x + values[6] * p.y + values[7] * m[0]));
    eq[2] = -(m[1] * m[5] + v.z * (values[5] * v.x + values[6] * v.y + values[7] * m[2]));
    eq[3] = -values[7] * m[1] * v.z;


#if defined(OCTREE_TRAVERSAL_AND_SOLVER) || defined(SPHERE_MARCHING_SOLVER)
    // Unroll method
    float derivative[3];
    derivative[0] = eq[1];
    derivative[1] = 2.0 * eq[2];
    derivative[2] = 3.0 * eq[3];

    float begin = leaf_t_in;
    float end = leaf_t_out;

    vec2 val = vec2(leaf_t_in, leaf_t_out);
    val = eq[3] * val * val * val +  eq[2] * val * val + eq[1] * val + eq[0];

    // Compute its two roots using the quadratic formula
    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];
    if (discriminant >= 0.0) {
        float sqrt_discriminant = sqrt(discriminant);
        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));
        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);
        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);

        root_0 = min(root_0, root_1);
        root_1 = max(root_0, root_1);

        vec2 tval = vec2(root_0, root_1);
        tval = eq[3] * tval * tval * tval +  eq[2] * tval * tval + eq[1] * tval + eq[0];

        if(val.x * tval.x <= 0) 
        {
            end = root_0; val.y = tval.x;
        }
        else if(tval.x * tval.y <= 0)
        {
            begin = root_0; end = root_1; val = tval;
        }
        else if(tval.y * val.y <= 0)
        {
            begin = root_1; val.x = tval.y;
        }
        else return false;
    }
    else if(val.x * val.y > 0.0) return false;

    float tolerance = (end - begin) * epsilon;
    float t = 0.5 * (begin + end);
    // float t = begin;
    for (int i = 0; i != 90; ++i) {
        // Evaluate the polynomial and its derivative
        vec2 value = vec2(eq[3] * t + eq[2], eq[3]);

        float aux = value.x;
        value = value * t + vec2(eq[1], aux);

        aux = value.x;
        value = value * t + vec2(eq[0], aux);

        // Shorten the interval
        bool right = val.x * value.x > 0.0;
        begin = right ? t : begin;
        end = right ? end : t;

        // Apply Newton's method
        float guess = t - value.x / value.y;
        // Pick a guess
        float middle = 0.5 * (begin + end);
        float next = (guess >= begin && guess <= end) ? guess : middle;
        // Move along or terminate
        bool done = abs(next - t) < tolerance;
        t = next;

        if (done || distanceScale * value.x < epsilon)
            break;
    }
    
    result = o + dir * t;
    return true;
#endif

#if defined(OCTREE_TRAVERSAL_AND_SH)
    float lastDistance = 1e8;
    uint it = 0;
    float t=leaf_t_in;
    while (lastDistance > epsilon && t < leaf_t_out && it < 128)
    {
        float t2 = t * t;
        lastDistance = distanceScale * (t * t2 * eq[3] + t2 * eq[2] + t * eq[1] + eq[0]);
        float dist = max(lastDistance, 0.0);
        t += dist;
        it += 1;
    }

    result = o + dir * t;
    return lastDistance < epsilon;
#endif

    // values[0] = uintBitsToFloat(octreeData[vIndex]); // S000
    // values[1] = uintBitsToFloat(octreeData[vIndex + 1]); // S100 - S000
    // values[2] = uintBitsToFloat(octreeData[vIndex + 2]); // S010
    // values[3] = uintBitsToFloat(octreeData[vIndex + 3]); //S110 - S010 - values[1]
    // values[4] = uintBitsToFloat(octreeData[vIndex + 4]); // S001
    // values[5] = uintBitsToFloat(octreeData[vIndex + 5]); // S101 - S001 (a)
    // values[6] = uintBitsToFloat(octreeData[vIndex + 6]); // S011
    // values[7] = uintBitsToFloat(octreeData[vIndex + 7]);

    // eq[0] = -p.x*p.y*p.z*values[0] + p.x*p.y*p.z*values[1] + p.x*p.y*p.z*values[2] - p.x*p.y*p.z*values[3] + p.x*p.y*p.z*values[4] - p.x*p.y*p.z*values[5] - p.x*p.y*p.z*values[6] + p.x*p.y*p.z*values[7] + 1.0*p.x*p.y*values[0] - 1.0*p.x*p.y*values[1] - 1.0*p.x*p.y*values[2] + 1.0*p.x*p.y*values[3] + 1.0*p.x*p.z*values[0] - 1.0*p.x*p.z*values[1] - 1.0*p.x*p.z*values[4] + 1.0*p.x*p.z*values[5] - 1.0*p.x*values[0] + 1.0*p.x*values[1] + 1.0*p.y*p.z*values[0] - 1.0*p.y*p.z*values[2] - 1.0*p.y*p.z*values[4] + 1.0*p.y*p.z*values[6] - 1.0*p.y*values[0] + 1.0*p.y*values[2] - 1.0*p.z*values[0] + 1.0*p.z*values[4] + 1.0*values[0];
    // eq[1] = -p.x*p.y*v.z*values[0] + p.x*p.y*v.z*values[1] + p.x*p.y*v.z*values[2] - p.x*p.y*v.z*values[3] + p.x*p.y*v.z*values[4] - p.x*p.y*v.z*values[5] - p.x*p.y*v.z*values[6] + p.x*p.y*v.z*values[7] - p.x*p.z*v.y*values[0] + p.x*p.z*v.y*values[1] + p.x*p.z*v.y*values[2] - p.x*p.z*v.y*values[3] + p.x*p.z*v.y*values[4] - p.x*p.z*v.y*values[5] - p.x*p.z*v.y*values[6] + p.x*p.z*v.y*values[7] + 1.0*p.x*v.y*values[0] - 1.0*p.x*v.y*values[1] - 1.0*p.x*v.y*values[2] + 1.0*p.x*v.y*values[3] + 1.0*p.x*v.z*values[0] - 1.0*p.x*v.z*values[1] - 1.0*p.x*v.z*values[4] + 1.0*p.x*v.z*values[5] - p.y*p.z*v.x*values[0] + p.y*p.z*v.x*values[1] + p.y*p.z*v.x*values[2] - p.y*p.z*v.x*values[3] + p.y*p.z*v.x*values[4] - p.y*p.z*v.x*values[5] - p.y*p.z*v.x*values[6] + p.y*p.z*v.x*values[7] + 1.0*p.y*v.x*values[0] - 1.0*p.y*v.x*values[1] - 1.0*p.y*v.x*values[2] + 1.0*p.y*v.x*values[3] + 1.0*p.y*v.z*values[0] - 1.0*p.y*v.z*values[2] - 1.0*p.y*v.z*values[4] + 1.0*p.y*v.z*values[6] + 1.0*p.z*v.x*values[0] - 1.0*p.z*v.x*values[1] - 1.0*p.z*v.x*values[4] + 1.0*p.z*v.x*values[5] + 1.0*p.z*v.y*values[0] - 1.0*p.z*v.y*values[2] - 1.0*p.z*v.y*values[4] + 1.0*p.z*v.y*values[6] - 1.0*v.x*values[0] + 1.0*v.x*values[1] - 1.0*v.y*values[0] + 1.0*v.y*values[2] - 1.0*v.z*values[0] + 1.0*v.z*values[4];
    // eq[2] = -p.x*v.y*v.z*values[0] + p.x*v.y*v.z*values[1] + p.x*v.y*v.z*values[2] - p.x*v.y*v.z*values[3] + p.x*v.y*v.z*values[4] - p.x*v.y*v.z*values[5] - p.x*v.y*v.z*values[6] + p.x*v.y*v.z*values[7] - p.y*v.x*v.z*values[0] + p.y*v.x*v.z*values[1] + p.y*v.x*v.z*values[2] - p.y*v.x*v.z*values[3] + p.y*v.x*v.z*values[4] - p.y*v.x*v.z*values[5] - p.y*v.x*v.z*values[6] + p.y*v.x*v.z*values[7] - p.z*v.x*v.y*values[0] + p.z*v.x*v.y*values[1] + p.z*v.x*v.y*values[2] - p.z*v.x*v.y*values[3] + p.z*v.x*v.y*values[4] - p.z*v.x*v.y*values[5] - p.z*v.x*v.y*values[6] + p.z*v.x*v.y*values[7] + 1.0*v.x*v.y*values[0] - 1.0*v.x*v.y*values[1] - 1.0*v.x*v.y*values[2] + 1.0*v.x*v.y*values[3] + 1.0*v.x*v.z*values[0] - 1.0*v.x*v.z*values[1] - 1.0*v.x*v.z*values[4] + 1.0*v.x*v.z*values[5] + 1.0*v.y*v.z*values[0] - 1.0*v.y*v.z*values[2] - 1.0*v.y*v.z*values[4] + 1.0*v.y*v.z*values[6];
    // eq[3] = -v.x*v.y*v.z*values[0] + v.x*v.y*v.z*values[1] + v.x*v.y*v.z*values[2] - v.x*v.y*v.z*values[3] + v.x*v.y*v.z*values[4] - v.x*v.y*v.z*values[5] - v.x*v.y*v.z*values[6] + v.x*v.y*v.z*values[7];
    
#endif
#ifdef USE_TRICUBIC_INTERPOLATION
    float[64] values;
    uint vIndex = leafNode & childrenIndexMask;
    for(int i=0; i < 64; i++)
    {
        values[i] = uintBitsToFloat(octreeData[vIndex + i]);
    }

    float[10] eq;

    eq[0] = pow(p.x, 3)*pow(p.y, 3)*pow(p.z, 3)*values[63] + pow(p.x, 3)*pow(p.y, 3)*pow(p.z, 2)*values[47] + pow(p.x, 3)*pow(p.y, 3)*p.z*values[31] + pow(p.x, 3)*pow(p.y, 3)*values[15] + pow(p.x, 3)*pow(p.y, 2)*pow(p.z, 3)*values[59] + pow(p.x, 3)*pow(p.y, 2)*pow(p.z, 2)*values[43] + pow(p.x, 3)*pow(p.y, 2)*p.z*values[27] + pow(p.x, 3)*pow(p.y, 2)*values[11] + pow(p.x, 3)*p.y*pow(p.z, 3)*values[55] + pow(p.x, 3)*p.y*pow(p.z, 2)*values[39] + pow(p.x, 3)*p.y*p.z*values[23] + pow(p.x, 3)*p.y*values[7] + pow(p.x, 3)*pow(p.z, 3)*values[51] + pow(p.x, 3)*pow(p.z, 2)*values[35] + pow(p.x, 3)*p.z*values[19] + pow(p.x, 3)*values[3] + pow(p.x, 2)*pow(p.y, 3)*pow(p.z, 3)*values[62] + pow(p.x, 2)*pow(p.y, 3)*pow(p.z, 2)*values[46] + pow(p.x, 2)*pow(p.y, 3)*p.z*values[30] + pow(p.x, 2)*pow(p.y, 3)*values[14] + pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 3)*values[58] + pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*values[42] + pow(p.x, 2)*pow(p.y, 2)*p.z*values[26] + pow(p.x, 2)*pow(p.y, 2)*values[10] + pow(p.x, 2)*p.y*pow(p.z, 3)*values[54] + pow(p.x, 2)*p.y*pow(p.z, 2)*values[38] + pow(p.x, 2)*p.y*p.z*values[22] + pow(p.x, 2)*p.y*values[6] + pow(p.x, 2)*pow(p.z, 3)*values[50] + pow(p.x, 2)*pow(p.z, 2)*values[34] + pow(p.x, 2)*p.z*values[18] + pow(p.x, 2)*values[2] + p.x*pow(p.y, 3)*pow(p.z, 3)*values[61] + p.x*pow(p.y, 3)*pow(p.z, 2)*values[45] + p.x*pow(p.y, 3)*p.z*values[29] + p.x*pow(p.y, 3)*values[13] + p.x*pow(p.y, 2)*pow(p.z, 3)*values[57] + p.x*pow(p.y, 2)*pow(p.z, 2)*values[41] + p.x*pow(p.y, 2)*p.z*values[25] + p.x*pow(p.y, 2)*values[9] + p.x*p.y*pow(p.z, 3)*values[53] + p.x*p.y*pow(p.z, 2)*values[37] + p.x*p.y*p.z*values[21] + p.x*p.y*values[5] + p.x*pow(p.z, 3)*values[49] + p.x*pow(p.z, 2)*values[33] + p.x*p.z*values[17] + p.x*values[1] + pow(p.y, 3)*pow(p.z, 3)*values[60] + pow(p.y, 3)*pow(p.z, 2)*values[44] + pow(p.y, 3)*p.z*values[28] + pow(p.y, 3)*values[12] + pow(p.y, 2)*pow(p.z, 3)*values[56] + pow(p.y, 2)*pow(p.z, 2)*values[40] + pow(p.y, 2)*p.z*values[24] + pow(p.y, 2)*values[8] + p.y*pow(p.z, 3)*values[52] + p.y*pow(p.z, 2)*values[36] + p.y*p.z*values[20] + p.y*values[4] + pow(p.z, 3)*values[48] + pow(p.z, 2)*values[32] + p.z*values[16] + values[0];
    eq[1] = 3*pow(p.x, 3)*pow(p.y, 3)*pow(p.z, 2)*v.z*values[63] + 2*pow(p.x, 3)*pow(p.y, 3)*p.z*v.z*values[47] + pow(p.x, 3)*pow(p.y, 3)*v.z*values[31] + 3*pow(p.x, 3)*pow(p.y, 2)*pow(p.z, 3)*v.y*values[63] + 3*pow(p.x, 3)*pow(p.y, 2)*pow(p.z, 2)*v.y*values[47] + 3*pow(p.x, 3)*pow(p.y, 2)*pow(p.z, 2)*v.z*values[59] + 3*pow(p.x, 3)*pow(p.y, 2)*p.z*v.y*values[31] + 2*pow(p.x, 3)*pow(p.y, 2)*p.z*v.z*values[43] + 3*pow(p.x, 3)*pow(p.y, 2)*v.y*values[15] + pow(p.x, 3)*pow(p.y, 2)*v.z*values[27] + 2*pow(p.x, 3)*p.y*pow(p.z, 3)*v.y*values[59] + 2*pow(p.x, 3)*p.y*pow(p.z, 2)*v.y*values[43] + 3*pow(p.x, 3)*p.y*pow(p.z, 2)*v.z*values[55] + 2*pow(p.x, 3)*p.y*p.z*v.y*values[27] + 2*pow(p.x, 3)*p.y*p.z*v.z*values[39] + 2*pow(p.x, 3)*p.y*v.y*values[11] + pow(p.x, 3)*p.y*v.z*values[23] + pow(p.x, 3)*pow(p.z, 3)*v.y*values[55] + pow(p.x, 3)*pow(p.z, 2)*v.y*values[39] + 3*pow(p.x, 3)*pow(p.z, 2)*v.z*values[51] + pow(p.x, 3)*p.z*v.y*values[23] + 2*pow(p.x, 3)*p.z*v.z*values[35] + pow(p.x, 3)*v.y*values[7] + pow(p.x, 3)*v.z*values[19] + 3*pow(p.x, 2)*pow(p.y, 3)*pow(p.z, 3)*v.x*values[63] + 3*pow(p.x, 2)*pow(p.y, 3)*pow(p.z, 2)*v.x*values[47] + 3*pow(p.x, 2)*pow(p.y, 3)*pow(p.z, 2)*v.z*values[62] + 3*pow(p.x, 2)*pow(p.y, 3)*p.z*v.x*values[31] + 2*pow(p.x, 2)*pow(p.y, 3)*p.z*v.z*values[46] + 3*pow(p.x, 2)*pow(p.y, 3)*v.x*values[15] + pow(p.x, 2)*pow(p.y, 3)*v.z*values[30] + 3*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 3)*v.x*values[59] + 3*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 3)*v.y*values[62] + 3*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*v.x*values[43] + 3*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*v.y*values[46] + 3*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*v.z*values[58] + 3*pow(p.x, 2)*pow(p.y, 2)*p.z*v.x*values[27] + 3*pow(p.x, 2)*pow(p.y, 2)*p.z*v.y*values[30] + 2*pow(p.x, 2)*pow(p.y, 2)*p.z*v.z*values[42] + 3*pow(p.x, 2)*pow(p.y, 2)*v.x*values[11] + 3*pow(p.x, 2)*pow(p.y, 2)*v.y*values[14] + pow(p.x, 2)*pow(p.y, 2)*v.z*values[26] + 3*pow(p.x, 2)*p.y*pow(p.z, 3)*v.x*values[55] + 2*pow(p.x, 2)*p.y*pow(p.z, 3)*v.y*values[58] + 3*pow(p.x, 2)*p.y*pow(p.z, 2)*v.x*values[39] + 2*pow(p.x, 2)*p.y*pow(p.z, 2)*v.y*values[42] + 3*pow(p.x, 2)*p.y*pow(p.z, 2)*v.z*values[54] + 3*pow(p.x, 2)*p.y*p.z*v.x*values[23] + 2*pow(p.x, 2)*p.y*p.z*v.y*values[26] + 2*pow(p.x, 2)*p.y*p.z*v.z*values[38] + 3*pow(p.x, 2)*p.y*v.x*values[7] + 2*pow(p.x, 2)*p.y*v.y*values[10] + pow(p.x, 2)*p.y*v.z*values[22] + 3*pow(p.x, 2)*pow(p.z, 3)*v.x*values[51] + pow(p.x, 2)*pow(p.z, 3)*v.y*values[54] + 3*pow(p.x, 2)*pow(p.z, 2)*v.x*values[35] + pow(p.x, 2)*pow(p.z, 2)*v.y*values[38] + 3*pow(p.x, 2)*pow(p.z, 2)*v.z*values[50] + 3*pow(p.x, 2)*p.z*v.x*values[19] + pow(p.x, 2)*p.z*v.y*values[22] + 2*pow(p.x, 2)*p.z*v.z*values[34] + 3*pow(p.x, 2)*v.x*values[3] + pow(p.x, 2)*v.y*values[6] + pow(p.x, 2)*v.z*values[18] + 2*p.x*pow(p.y, 3)*pow(p.z, 3)*v.x*values[62] + 2*p.x*pow(p.y, 3)*pow(p.z, 2)*v.x*values[46] + 3*p.x*pow(p.y, 3)*pow(p.z, 2)*v.z*values[61] + 2*p.x*pow(p.y, 3)*p.z*v.x*values[30] + 2*p.x*pow(p.y, 3)*p.z*v.z*values[45] + 2*p.x*pow(p.y, 3)*v.x*values[14] + p.x*pow(p.y, 3)*v.z*values[29] + 2*p.x*pow(p.y, 2)*pow(p.z, 3)*v.x*values[58] + 3*p.x*pow(p.y, 2)*pow(p.z, 3)*v.y*values[61] + 2*p.x*pow(p.y, 2)*pow(p.z, 2)*v.x*values[42] + 3*p.x*pow(p.y, 2)*pow(p.z, 2)*v.y*values[45] + 3*p.x*pow(p.y, 2)*pow(p.z, 2)*v.z*values[57] + 2*p.x*pow(p.y, 2)*p.z*v.x*values[26] + 3*p.x*pow(p.y, 2)*p.z*v.y*values[29] + 2*p.x*pow(p.y, 2)*p.z*v.z*values[41] + 2*p.x*pow(p.y, 2)*v.x*values[10] + 3*p.x*pow(p.y, 2)*v.y*values[13] + p.x*pow(p.y, 2)*v.z*values[25] + 2*p.x*p.y*pow(p.z, 3)*v.x*values[54] + 2*p.x*p.y*pow(p.z, 3)*v.y*values[57] + 2*p.x*p.y*pow(p.z, 2)*v.x*values[38] + 2*p.x*p.y*pow(p.z, 2)*v.y*values[41] + 3*p.x*p.y*pow(p.z, 2)*v.z*values[53] + 2*p.x*p.y*p.z*v.x*values[22] + 2*p.x*p.y*p.z*v.y*values[25] + 2*p.x*p.y*p.z*v.z*values[37] + 2*p.x*p.y*v.x*values[6] + 2*p.x*p.y*v.y*values[9] + p.x*p.y*v.z*values[21] + 2*p.x*pow(p.z, 3)*v.x*values[50] + p.x*pow(p.z, 3)*v.y*values[53] + 2*p.x*pow(p.z, 2)*v.x*values[34] + p.x*pow(p.z, 2)*v.y*values[37] + 3*p.x*pow(p.z, 2)*v.z*values[49] + 2*p.x*p.z*v.x*values[18] + p.x*p.z*v.y*values[21] + 2*p.x*p.z*v.z*values[33] + 2*p.x*v.x*values[2] + p.x*v.y*values[5] + p.x*v.z*values[17] + pow(p.y, 3)*pow(p.z, 3)*v.x*values[61] + pow(p.y, 3)*pow(p.z, 2)*v.x*values[45] + 3*pow(p.y, 3)*pow(p.z, 2)*v.z*values[60] + pow(p.y, 3)*p.z*v.x*values[29] + 2*pow(p.y, 3)*p.z*v.z*values[44] + pow(p.y, 3)*v.x*values[13] + pow(p.y, 3)*v.z*values[28] + pow(p.y, 2)*pow(p.z, 3)*v.x*values[57] + 3*pow(p.y, 2)*pow(p.z, 3)*v.y*values[60] + pow(p.y, 2)*pow(p.z, 2)*v.x*values[41] + 3*pow(p.y, 2)*pow(p.z, 2)*v.y*values[44] + 3*pow(p.y, 2)*pow(p.z, 2)*v.z*values[56] + pow(p.y, 2)*p.z*v.x*values[25] + 3*pow(p.y, 2)*p.z*v.y*values[28] + 2*pow(p.y, 2)*p.z*v.z*values[40] + pow(p.y, 2)*v.x*values[9] + 3*pow(p.y, 2)*v.y*values[12] + pow(p.y, 2)*v.z*values[24] + p.y*pow(p.z, 3)*v.x*values[53] + 2*p.y*pow(p.z, 3)*v.y*values[56] + p.y*pow(p.z, 2)*v.x*values[37] + 2*p.y*pow(p.z, 2)*v.y*values[40] + 3*p.y*pow(p.z, 2)*v.z*values[52] + p.y*p.z*v.x*values[21] + 2*p.y*p.z*v.y*values[24] + 2*p.y*p.z*v.z*values[36] + p.y*v.x*values[5] + 2*p.y*v.y*values[8] + p.y*v.z*values[20] + pow(p.z, 3)*v.x*values[49] + pow(p.z, 3)*v.y*values[52] + pow(p.z, 2)*v.x*values[33] + pow(p.z, 2)*v.y*values[36] + 3*pow(p.z, 2)*v.z*values[48] + p.z*v.x*values[17] + p.z*v.y*values[20] + 2*p.z*v.z*values[32] + v.x*values[1] + v.y*values[4] + v.z*values[16];
    eq[2] = 3*pow(p.x, 3)*pow(p.y, 3)*p.z*pow(v.z, 2)*values[63] + pow(p.x, 3)*pow(p.y, 3)*pow(v.z, 2)*values[47] + 9*pow(p.x, 3)*pow(p.y, 2)*pow(p.z, 2)*v.y*v.z*values[63] + 6*pow(p.x, 3)*pow(p.y, 2)*p.z*v.y*v.z*values[47] + 3*pow(p.x, 3)*pow(p.y, 2)*p.z*pow(v.z, 2)*values[59] + 3*pow(p.x, 3)*pow(p.y, 2)*v.y*v.z*values[31] + pow(p.x, 3)*pow(p.y, 2)*pow(v.z, 2)*values[43] + 3*pow(p.x, 3)*p.y*pow(p.z, 3)*pow(v.y, 2)*values[63] + 3*pow(p.x, 3)*p.y*pow(p.z, 2)*pow(v.y, 2)*values[47] + 6*pow(p.x, 3)*p.y*pow(p.z, 2)*v.y*v.z*values[59] + 3*pow(p.x, 3)*p.y*p.z*pow(v.y, 2)*values[31] + 4*pow(p.x, 3)*p.y*p.z*v.y*v.z*values[43] + 3*pow(p.x, 3)*p.y*p.z*pow(v.z, 2)*values[55] + 3*pow(p.x, 3)*p.y*pow(v.y, 2)*values[15] + 2*pow(p.x, 3)*p.y*v.y*v.z*values[27] + pow(p.x, 3)*p.y*pow(v.z, 2)*values[39] + pow(p.x, 3)*pow(p.z, 3)*pow(v.y, 2)*values[59] + pow(p.x, 3)*pow(p.z, 2)*pow(v.y, 2)*values[43] + 3*pow(p.x, 3)*pow(p.z, 2)*v.y*v.z*values[55] + pow(p.x, 3)*p.z*pow(v.y, 2)*values[27] + 2*pow(p.x, 3)*p.z*v.y*v.z*values[39] + 3*pow(p.x, 3)*p.z*pow(v.z, 2)*values[51] + pow(p.x, 3)*pow(v.y, 2)*values[11] + pow(p.x, 3)*v.y*v.z*values[23] + pow(p.x, 3)*pow(v.z, 2)*values[35] + 9*pow(p.x, 2)*pow(p.y, 3)*pow(p.z, 2)*v.x*v.z*values[63] + 6*pow(p.x, 2)*pow(p.y, 3)*p.z*v.x*v.z*values[47] + 3*pow(p.x, 2)*pow(p.y, 3)*p.z*pow(v.z, 2)*values[62] + 3*pow(p.x, 2)*pow(p.y, 3)*v.x*v.z*values[31] + pow(p.x, 2)*pow(p.y, 3)*pow(v.z, 2)*values[46] + 9*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 3)*v.x*v.y*values[63] + 9*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*v.x*v.y*values[47] + 9*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*v.x*v.z*values[59] + 9*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*v.y*v.z*values[62] + 9*pow(p.x, 2)*pow(p.y, 2)*p.z*v.x*v.y*values[31] + 6*pow(p.x, 2)*pow(p.y, 2)*p.z*v.x*v.z*values[43] + 6*pow(p.x, 2)*pow(p.y, 2)*p.z*v.y*v.z*values[46] + 3*pow(p.x, 2)*pow(p.y, 2)*p.z*pow(v.z, 2)*values[58] + 9*pow(p.x, 2)*pow(p.y, 2)*v.x*v.y*values[15] + 3*pow(p.x, 2)*pow(p.y, 2)*v.x*v.z*values[27] + 3*pow(p.x, 2)*pow(p.y, 2)*v.y*v.z*values[30] + pow(p.x, 2)*pow(p.y, 2)*pow(v.z, 2)*values[42] + 6*pow(p.x, 2)*p.y*pow(p.z, 3)*v.x*v.y*values[59] + 3*pow(p.x, 2)*p.y*pow(p.z, 3)*pow(v.y, 2)*values[62] + 6*pow(p.x, 2)*p.y*pow(p.z, 2)*v.x*v.y*values[43] + 9*pow(p.x, 2)*p.y*pow(p.z, 2)*v.x*v.z*values[55] + 3*pow(p.x, 2)*p.y*pow(p.z, 2)*pow(v.y, 2)*values[46] + 6*pow(p.x, 2)*p.y*pow(p.z, 2)*v.y*v.z*values[58] + 6*pow(p.x, 2)*p.y*p.z*v.x*v.y*values[27] + 6*pow(p.x, 2)*p.y*p.z*v.x*v.z*values[39] + 3*pow(p.x, 2)*p.y*p.z*pow(v.y, 2)*values[30] + 4*pow(p.x, 2)*p.y*p.z*v.y*v.z*values[42] + 3*pow(p.x, 2)*p.y*p.z*pow(v.z, 2)*values[54] + 6*pow(p.x, 2)*p.y*v.x*v.y*values[11] + 3*pow(p.x, 2)*p.y*v.x*v.z*values[23] + 3*pow(p.x, 2)*p.y*pow(v.y, 2)*values[14] + 2*pow(p.x, 2)*p.y*v.y*v.z*values[26] + pow(p.x, 2)*p.y*pow(v.z, 2)*values[38] + 3*pow(p.x, 2)*pow(p.z, 3)*v.x*v.y*values[55] + pow(p.x, 2)*pow(p.z, 3)*pow(v.y, 2)*values[58] + 3*pow(p.x, 2)*pow(p.z, 2)*v.x*v.y*values[39] + 9*pow(p.x, 2)*pow(p.z, 2)*v.x*v.z*values[51] + pow(p.x, 2)*pow(p.z, 2)*pow(v.y, 2)*values[42] + 3*pow(p.x, 2)*pow(p.z, 2)*v.y*v.z*values[54] + 3*pow(p.x, 2)*p.z*v.x*v.y*values[23] + 6*pow(p.x, 2)*p.z*v.x*v.z*values[35] + pow(p.x, 2)*p.z*pow(v.y, 2)*values[26] + 2*pow(p.x, 2)*p.z*v.y*v.z*values[38] + 3*pow(p.x, 2)*p.z*pow(v.z, 2)*values[50] + 3*pow(p.x, 2)*v.x*v.y*values[7] + 3*pow(p.x, 2)*v.x*v.z*values[19] + pow(p.x, 2)*pow(v.y, 2)*values[10] + pow(p.x, 2)*v.y*v.z*values[22] + pow(p.x, 2)*pow(v.z, 2)*values[34] + 3*p.x*pow(p.y, 3)*pow(p.z, 3)*pow(v.x, 2)*values[63] + 3*p.x*pow(p.y, 3)*pow(p.z, 2)*pow(v.x, 2)*values[47] + 6*p.x*pow(p.y, 3)*pow(p.z, 2)*v.x*v.z*values[62] + 3*p.x*pow(p.y, 3)*p.z*pow(v.x, 2)*values[31] + 4*p.x*pow(p.y, 3)*p.z*v.x*v.z*values[46] + 3*p.x*pow(p.y, 3)*p.z*pow(v.z, 2)*values[61] + 3*p.x*pow(p.y, 3)*pow(v.x, 2)*values[15] + 2*p.x*pow(p.y, 3)*v.x*v.z*values[30] + p.x*pow(p.y, 3)*pow(v.z, 2)*values[45] + 3*p.x*pow(p.y, 2)*pow(p.z, 3)*pow(v.x, 2)*values[59] + 6*p.x*pow(p.y, 2)*pow(p.z, 3)*v.x*v.y*values[62] + 3*p.x*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*values[43] + 6*p.x*pow(p.y, 2)*pow(p.z, 2)*v.x*v.y*values[46] + 6*p.x*pow(p.y, 2)*pow(p.z, 2)*v.x*v.z*values[58] + 9*p.x*pow(p.y, 2)*pow(p.z, 2)*v.y*v.z*values[61] + 3*p.x*pow(p.y, 2)*p.z*pow(v.x, 2)*values[27] + 6*p.x*pow(p.y, 2)*p.z*v.x*v.y*values[30] + 4*p.x*pow(p.y, 2)*p.z*v.x*v.z*values[42] + 6*p.x*pow(p.y, 2)*p.z*v.y*v.z*values[45] + 3*p.x*pow(p.y, 2)*p.z*pow(v.z, 2)*values[57] + 3*p.x*pow(p.y, 2)*pow(v.x, 2)*values[11] + 6*p.x*pow(p.y, 2)*v.x*v.y*values[14] + 2*p.x*pow(p.y, 2)*v.x*v.z*values[26] + 3*p.x*pow(p.y, 2)*v.y*v.z*values[29] + p.x*pow(p.y, 2)*pow(v.z, 2)*values[41] + 3*p.x*p.y*pow(p.z, 3)*pow(v.x, 2)*values[55] + 4*p.x*p.y*pow(p.z, 3)*v.x*v.y*values[58] + 3*p.x*p.y*pow(p.z, 3)*pow(v.y, 2)*values[61] + 3*p.x*p.y*pow(p.z, 2)*pow(v.x, 2)*values[39] + 4*p.x*p.y*pow(p.z, 2)*v.x*v.y*values[42] + 6*p.x*p.y*pow(p.z, 2)*v.x*v.z*values[54] + 3*p.x*p.y*pow(p.z, 2)*pow(v.y, 2)*values[45] + 6*p.x*p.y*pow(p.z, 2)*v.y*v.z*values[57] + 3*p.x*p.y*p.z*pow(v.x, 2)*values[23] + 4*p.x*p.y*p.z*v.x*v.y*values[26] + 4*p.x*p.y*p.z*v.x*v.z*values[38] + 3*p.x*p.y*p.z*pow(v.y, 2)*values[29] + 4*p.x*p.y*p.z*v.y*v.z*values[41] + 3*p.x*p.y*p.z*pow(v.z, 2)*values[53] + 3*p.x*p.y*pow(v.x, 2)*values[7] + 4*p.x*p.y*v.x*v.y*values[10] + 2*p.x*p.y*v.x*v.z*values[22] + 3*p.x*p.y*pow(v.y, 2)*values[13] + 2*p.x*p.y*v.y*v.z*values[25] + p.x*p.y*pow(v.z, 2)*values[37] + 3*p.x*pow(p.z, 3)*pow(v.x, 2)*values[51] + 2*p.x*pow(p.z, 3)*v.x*v.y*values[54] + p.x*pow(p.z, 3)*pow(v.y, 2)*values[57] + 3*p.x*pow(p.z, 2)*pow(v.x, 2)*values[35] + 2*p.x*pow(p.z, 2)*v.x*v.y*values[38] + 6*p.x*pow(p.z, 2)*v.x*v.z*values[50] + p.x*pow(p.z, 2)*pow(v.y, 2)*values[41] + 3*p.x*pow(p.z, 2)*v.y*v.z*values[53] + 3*p.x*p.z*pow(v.x, 2)*values[19] + 2*p.x*p.z*v.x*v.y*values[22] + 4*p.x*p.z*v.x*v.z*values[34] + p.x*p.z*pow(v.y, 2)*values[25] + 2*p.x*p.z*v.y*v.z*values[37] + 3*p.x*p.z*pow(v.z, 2)*values[49] + 3*p.x*pow(v.x, 2)*values[3] + 2*p.x*v.x*v.y*values[6] + 2*p.x*v.x*v.z*values[18] + p.x*pow(v.y, 2)*values[9] + p.x*v.y*v.z*values[21] + p.x*pow(v.z, 2)*values[33] + pow(p.y, 3)*pow(p.z, 3)*pow(v.x, 2)*values[62] + pow(p.y, 3)*pow(p.z, 2)*pow(v.x, 2)*values[46] + 3*pow(p.y, 3)*pow(p.z, 2)*v.x*v.z*values[61] + pow(p.y, 3)*p.z*pow(v.x, 2)*values[30] + 2*pow(p.y, 3)*p.z*v.x*v.z*values[45] + 3*pow(p.y, 3)*p.z*pow(v.z, 2)*values[60] + pow(p.y, 3)*pow(v.x, 2)*values[14] + pow(p.y, 3)*v.x*v.z*values[29] + pow(p.y, 3)*pow(v.z, 2)*values[44] + pow(p.y, 2)*pow(p.z, 3)*pow(v.x, 2)*values[58] + 3*pow(p.y, 2)*pow(p.z, 3)*v.x*v.y*values[61] + pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*values[42] + 3*pow(p.y, 2)*pow(p.z, 2)*v.x*v.y*values[45] + 3*pow(p.y, 2)*pow(p.z, 2)*v.x*v.z*values[57] + 9*pow(p.y, 2)*pow(p.z, 2)*v.y*v.z*values[60] + pow(p.y, 2)*p.z*pow(v.x, 2)*values[26] + 3*pow(p.y, 2)*p.z*v.x*v.y*values[29] + 2*pow(p.y, 2)*p.z*v.x*v.z*values[41] + 6*pow(p.y, 2)*p.z*v.y*v.z*values[44] + 3*pow(p.y, 2)*p.z*pow(v.z, 2)*values[56] + pow(p.y, 2)*pow(v.x, 2)*values[10] + 3*pow(p.y, 2)*v.x*v.y*values[13] + pow(p.y, 2)*v.x*v.z*values[25] + 3*pow(p.y, 2)*v.y*v.z*values[28] + pow(p.y, 2)*pow(v.z, 2)*values[40] + p.y*pow(p.z, 3)*pow(v.x, 2)*values[54] + 2*p.y*pow(p.z, 3)*v.x*v.y*values[57] + 3*p.y*pow(p.z, 3)*pow(v.y, 2)*values[60] + p.y*pow(p.z, 2)*pow(v.x, 2)*values[38] + 2*p.y*pow(p.z, 2)*v.x*v.y*values[41] + 3*p.y*pow(p.z, 2)*v.x*v.z*values[53] + 3*p.y*pow(p.z, 2)*pow(v.y, 2)*values[44] + 6*p.y*pow(p.z, 2)*v.y*v.z*values[56] + p.y*p.z*pow(v.x, 2)*values[22] + 2*p.y*p.z*v.x*v.y*values[25] + 2*p.y*p.z*v.x*v.z*values[37] + 3*p.y*p.z*pow(v.y, 2)*values[28] + 4*p.y*p.z*v.y*v.z*values[40] + 3*p.y*p.z*pow(v.z, 2)*values[52] + p.y*pow(v.x, 2)*values[6] + 2*p.y*v.x*v.y*values[9] + p.y*v.x*v.z*values[21] + 3*p.y*pow(v.y, 2)*values[12] + 2*p.y*v.y*v.z*values[24] + p.y*pow(v.z, 2)*values[36] + pow(p.z, 3)*pow(v.x, 2)*values[50] + pow(p.z, 3)*v.x*v.y*values[53] + pow(p.z, 3)*pow(v.y, 2)*values[56] + pow(p.z, 2)*pow(v.x, 2)*values[34] + pow(p.z, 2)*v.x*v.y*values[37] + 3*pow(p.z, 2)*v.x*v.z*values[49] + pow(p.z, 2)*pow(v.y, 2)*values[40] + 3*pow(p.z, 2)*v.y*v.z*values[52] + p.z*pow(v.x, 2)*values[18] + p.z*v.x*v.y*values[21] + 2*p.z*v.x*v.z*values[33] + p.z*pow(v.y, 2)*values[24] + 2*p.z*v.y*v.z*values[36] + 3*p.z*pow(v.z, 2)*values[48] + pow(v.x, 2)*values[2] + v.x*v.y*values[5] + v.x*v.z*values[17] + pow(v.y, 2)*values[8] + v.y*v.z*values[20] + pow(v.z, 2)*values[32];
    eq[3] = pow(p.x, 3)*pow(p.y, 3)*pow(v.z, 3)*values[63] + 9*pow(p.x, 3)*pow(p.y, 2)*p.z*v.y*pow(v.z, 2)*values[63] + 3*pow(p.x, 3)*pow(p.y, 2)*v.y*pow(v.z, 2)*values[47] + pow(p.x, 3)*pow(p.y, 2)*pow(v.z, 3)*values[59] + 9*pow(p.x, 3)*p.y*pow(p.z, 2)*pow(v.y, 2)*v.z*values[63] + 6*pow(p.x, 3)*p.y*p.z*pow(v.y, 2)*v.z*values[47] + 6*pow(p.x, 3)*p.y*p.z*v.y*pow(v.z, 2)*values[59] + 3*pow(p.x, 3)*p.y*pow(v.y, 2)*v.z*values[31] + 2*pow(p.x, 3)*p.y*v.y*pow(v.z, 2)*values[43] + pow(p.x, 3)*p.y*pow(v.z, 3)*values[55] + pow(p.x, 3)*pow(p.z, 3)*pow(v.y, 3)*values[63] + pow(p.x, 3)*pow(p.z, 2)*pow(v.y, 3)*values[47] + 3*pow(p.x, 3)*pow(p.z, 2)*pow(v.y, 2)*v.z*values[59] + pow(p.x, 3)*p.z*pow(v.y, 3)*values[31] + 2*pow(p.x, 3)*p.z*pow(v.y, 2)*v.z*values[43] + 3*pow(p.x, 3)*p.z*v.y*pow(v.z, 2)*values[55] + pow(p.x, 3)*pow(v.y, 3)*values[15] + pow(p.x, 3)*pow(v.y, 2)*v.z*values[27] + pow(p.x, 3)*v.y*pow(v.z, 2)*values[39] + pow(p.x, 3)*pow(v.z, 3)*values[51] + 9*pow(p.x, 2)*pow(p.y, 3)*p.z*v.x*pow(v.z, 2)*values[63] + 3*pow(p.x, 2)*pow(p.y, 3)*v.x*pow(v.z, 2)*values[47] + pow(p.x, 2)*pow(p.y, 3)*pow(v.z, 3)*values[62] + 27*pow(p.x, 2)*pow(p.y, 2)*pow(p.z, 2)*v.x*v.y*v.z*values[63] + 18*pow(p.x, 2)*pow(p.y, 2)*p.z*v.x*v.y*v.z*values[47] + 9*pow(p.x, 2)*pow(p.y, 2)*p.z*v.x*pow(v.z, 2)*values[59] + 9*pow(p.x, 2)*pow(p.y, 2)*p.z*v.y*pow(v.z, 2)*values[62] + 9*pow(p.x, 2)*pow(p.y, 2)*v.x*v.y*v.z*values[31] + 3*pow(p.x, 2)*pow(p.y, 2)*v.x*pow(v.z, 2)*values[43] + 3*pow(p.x, 2)*pow(p.y, 2)*v.y*pow(v.z, 2)*values[46] + pow(p.x, 2)*pow(p.y, 2)*pow(v.z, 3)*values[58] + 9*pow(p.x, 2)*p.y*pow(p.z, 3)*v.x*pow(v.y, 2)*values[63] + 9*pow(p.x, 2)*p.y*pow(p.z, 2)*v.x*pow(v.y, 2)*values[47] + 18*pow(p.x, 2)*p.y*pow(p.z, 2)*v.x*v.y*v.z*values[59] + 9*pow(p.x, 2)*p.y*pow(p.z, 2)*pow(v.y, 2)*v.z*values[62] + 9*pow(p.x, 2)*p.y*p.z*v.x*pow(v.y, 2)*values[31] + 12*pow(p.x, 2)*p.y*p.z*v.x*v.y*v.z*values[43] + 9*pow(p.x, 2)*p.y*p.z*v.x*pow(v.z, 2)*values[55] + 6*pow(p.x, 2)*p.y*p.z*pow(v.y, 2)*v.z*values[46] + 6*pow(p.x, 2)*p.y*p.z*v.y*pow(v.z, 2)*values[58] + 9*pow(p.x, 2)*p.y*v.x*pow(v.y, 2)*values[15] + 6*pow(p.x, 2)*p.y*v.x*v.y*v.z*values[27] + 3*pow(p.x, 2)*p.y*v.x*pow(v.z, 2)*values[39] + 3*pow(p.x, 2)*p.y*pow(v.y, 2)*v.z*values[30] + 2*pow(p.x, 2)*p.y*v.y*pow(v.z, 2)*values[42] + pow(p.x, 2)*p.y*pow(v.z, 3)*values[54] + 3*pow(p.x, 2)*pow(p.z, 3)*v.x*pow(v.y, 2)*values[59] + pow(p.x, 2)*pow(p.z, 3)*pow(v.y, 3)*values[62] + 3*pow(p.x, 2)*pow(p.z, 2)*v.x*pow(v.y, 2)*values[43] + 9*pow(p.x, 2)*pow(p.z, 2)*v.x*v.y*v.z*values[55] + pow(p.x, 2)*pow(p.z, 2)*pow(v.y, 3)*values[46] + 3*pow(p.x, 2)*pow(p.z, 2)*pow(v.y, 2)*v.z*values[58] + 3*pow(p.x, 2)*p.z*v.x*pow(v.y, 2)*values[27] + 6*pow(p.x, 2)*p.z*v.x*v.y*v.z*values[39] + 9*pow(p.x, 2)*p.z*v.x*pow(v.z, 2)*values[51] + pow(p.x, 2)*p.z*pow(v.y, 3)*values[30] + 2*pow(p.x, 2)*p.z*pow(v.y, 2)*v.z*values[42] + 3*pow(p.x, 2)*p.z*v.y*pow(v.z, 2)*values[54] + 3*pow(p.x, 2)*v.x*pow(v.y, 2)*values[11] + 3*pow(p.x, 2)*v.x*v.y*v.z*values[23] + 3*pow(p.x, 2)*v.x*pow(v.z, 2)*values[35] + pow(p.x, 2)*pow(v.y, 3)*values[14] + pow(p.x, 2)*pow(v.y, 2)*v.z*values[26] + pow(p.x, 2)*v.y*pow(v.z, 2)*values[38] + pow(p.x, 2)*pow(v.z, 3)*values[50] + 9*p.x*pow(p.y, 3)*pow(p.z, 2)*pow(v.x, 2)*v.z*values[63] + 6*p.x*pow(p.y, 3)*p.z*pow(v.x, 2)*v.z*values[47] + 6*p.x*pow(p.y, 3)*p.z*v.x*pow(v.z, 2)*values[62] + 3*p.x*pow(p.y, 3)*pow(v.x, 2)*v.z*values[31] + 2*p.x*pow(p.y, 3)*v.x*pow(v.z, 2)*values[46] + p.x*pow(p.y, 3)*pow(v.z, 3)*values[61] + 9*p.x*pow(p.y, 2)*pow(p.z, 3)*pow(v.x, 2)*v.y*values[63] + 9*p.x*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*v.y*values[47] + 9*p.x*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*v.z*values[59] + 18*p.x*pow(p.y, 2)*pow(p.z, 2)*v.x*v.y*v.z*values[62] + 9*p.x*pow(p.y, 2)*p.z*pow(v.x, 2)*v.y*values[31] + 6*p.x*pow(p.y, 2)*p.z*pow(v.x, 2)*v.z*values[43] + 12*p.x*pow(p.y, 2)*p.z*v.x*v.y*v.z*values[46] + 6*p.x*pow(p.y, 2)*p.z*v.x*pow(v.z, 2)*values[58] + 9*p.x*pow(p.y, 2)*p.z*v.y*pow(v.z, 2)*values[61] + 9*p.x*pow(p.y, 2)*pow(v.x, 2)*v.y*values[15] + 3*p.x*pow(p.y, 2)*pow(v.x, 2)*v.z*values[27] + 6*p.x*pow(p.y, 2)*v.x*v.y*v.z*values[30] + 2*p.x*pow(p.y, 2)*v.x*pow(v.z, 2)*values[42] + 3*p.x*pow(p.y, 2)*v.y*pow(v.z, 2)*values[45] + p.x*pow(p.y, 2)*pow(v.z, 3)*values[57] + 6*p.x*p.y*pow(p.z, 3)*pow(v.x, 2)*v.y*values[59] + 6*p.x*p.y*pow(p.z, 3)*v.x*pow(v.y, 2)*values[62] + 6*p.x*p.y*pow(p.z, 2)*pow(v.x, 2)*v.y*values[43] + 9*p.x*p.y*pow(p.z, 2)*pow(v.x, 2)*v.z*values[55] + 6*p.x*p.y*pow(p.z, 2)*v.x*pow(v.y, 2)*values[46] + 12*p.x*p.y*pow(p.z, 2)*v.x*v.y*v.z*values[58] + 9*p.x*p.y*pow(p.z, 2)*pow(v.y, 2)*v.z*values[61] + 6*p.x*p.y*p.z*pow(v.x, 2)*v.y*values[27] + 6*p.x*p.y*p.z*pow(v.x, 2)*v.z*values[39] + 6*p.x*p.y*p.z*v.x*pow(v.y, 2)*values[30] + 8*p.x*p.y*p.z*v.x*v.y*v.z*values[42] + 6*p.x*p.y*p.z*v.x*pow(v.z, 2)*values[54] + 6*p.x*p.y*p.z*pow(v.y, 2)*v.z*values[45] + 6*p.x*p.y*p.z*v.y*pow(v.z, 2)*values[57] + 6*p.x*p.y*pow(v.x, 2)*v.y*values[11] + 3*p.x*p.y*pow(v.x, 2)*v.z*values[23] + 6*p.x*p.y*v.x*pow(v.y, 2)*values[14] + 4*p.x*p.y*v.x*v.y*v.z*values[26] + 2*p.x*p.y*v.x*pow(v.z, 2)*values[38] + 3*p.x*p.y*pow(v.y, 2)*v.z*values[29] + 2*p.x*p.y*v.y*pow(v.z, 2)*values[41] + p.x*p.y*pow(v.z, 3)*values[53] + 3*p.x*pow(p.z, 3)*pow(v.x, 2)*v.y*values[55] + 2*p.x*pow(p.z, 3)*v.x*pow(v.y, 2)*values[58] + p.x*pow(p.z, 3)*pow(v.y, 3)*values[61] + 3*p.x*pow(p.z, 2)*pow(v.x, 2)*v.y*values[39] + 9*p.x*pow(p.z, 2)*pow(v.x, 2)*v.z*values[51] + 2*p.x*pow(p.z, 2)*v.x*pow(v.y, 2)*values[42] + 6*p.x*pow(p.z, 2)*v.x*v.y*v.z*values[54] + p.x*pow(p.z, 2)*pow(v.y, 3)*values[45] + 3*p.x*pow(p.z, 2)*pow(v.y, 2)*v.z*values[57] + 3*p.x*p.z*pow(v.x, 2)*v.y*values[23] + 6*p.x*p.z*pow(v.x, 2)*v.z*values[35] + 2*p.x*p.z*v.x*pow(v.y, 2)*values[26] + 4*p.x*p.z*v.x*v.y*v.z*values[38] + 6*p.x*p.z*v.x*pow(v.z, 2)*values[50] + p.x*p.z*pow(v.y, 3)*values[29] + 2*p.x*p.z*pow(v.y, 2)*v.z*values[41] + 3*p.x*p.z*v.y*pow(v.z, 2)*values[53] + 3*p.x*pow(v.x, 2)*v.y*values[7] + 3*p.x*pow(v.x, 2)*v.z*values[19] + 2*p.x*v.x*pow(v.y, 2)*values[10] + 2*p.x*v.x*v.y*v.z*values[22] + 2*p.x*v.x*pow(v.z, 2)*values[34] + p.x*pow(v.y, 3)*values[13] + p.x*pow(v.y, 2)*v.z*values[25] + p.x*v.y*pow(v.z, 2)*values[37] + p.x*pow(v.z, 3)*values[49] + pow(p.y, 3)*pow(p.z, 3)*pow(v.x, 3)*values[63] + pow(p.y, 3)*pow(p.z, 2)*pow(v.x, 3)*values[47] + 3*pow(p.y, 3)*pow(p.z, 2)*pow(v.x, 2)*v.z*values[62] + pow(p.y, 3)*p.z*pow(v.x, 3)*values[31] + 2*pow(p.y, 3)*p.z*pow(v.x, 2)*v.z*values[46] + 3*pow(p.y, 3)*p.z*v.x*pow(v.z, 2)*values[61] + pow(p.y, 3)*pow(v.x, 3)*values[15] + pow(p.y, 3)*pow(v.x, 2)*v.z*values[30] + pow(p.y, 3)*v.x*pow(v.z, 2)*values[45] + pow(p.y, 3)*pow(v.z, 3)*values[60] + pow(p.y, 2)*pow(p.z, 3)*pow(v.x, 3)*values[59] + 3*pow(p.y, 2)*pow(p.z, 3)*pow(v.x, 2)*v.y*values[62] + pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 3)*values[43] + 3*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*v.y*values[46] + 3*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*v.z*values[58] + 9*pow(p.y, 2)*pow(p.z, 2)*v.x*v.y*v.z*values[61] + pow(p.y, 2)*p.z*pow(v.x, 3)*values[27] + 3*pow(p.y, 2)*p.z*pow(v.x, 2)*v.y*values[30] + 2*pow(p.y, 2)*p.z*pow(v.x, 2)*v.z*values[42] + 6*pow(p.y, 2)*p.z*v.x*v.y*v.z*values[45] + 3*pow(p.y, 2)*p.z*v.x*pow(v.z, 2)*values[57] + 9*pow(p.y, 2)*p.z*v.y*pow(v.z, 2)*values[60] + pow(p.y, 2)*pow(v.x, 3)*values[11] + 3*pow(p.y, 2)*pow(v.x, 2)*v.y*values[14] + pow(p.y, 2)*pow(v.x, 2)*v.z*values[26] + 3*pow(p.y, 2)*v.x*v.y*v.z*values[29] + pow(p.y, 2)*v.x*pow(v.z, 2)*values[41] + 3*pow(p.y, 2)*v.y*pow(v.z, 2)*values[44] + pow(p.y, 2)*pow(v.z, 3)*values[56] + p.y*pow(p.z, 3)*pow(v.x, 3)*values[55] + 2*p.y*pow(p.z, 3)*pow(v.x, 2)*v.y*values[58] + 3*p.y*pow(p.z, 3)*v.x*pow(v.y, 2)*values[61] + p.y*pow(p.z, 2)*pow(v.x, 3)*values[39] + 2*p.y*pow(p.z, 2)*pow(v.x, 2)*v.y*values[42] + 3*p.y*pow(p.z, 2)*pow(v.x, 2)*v.z*values[54] + 3*p.y*pow(p.z, 2)*v.x*pow(v.y, 2)*values[45] + 6*p.y*pow(p.z, 2)*v.x*v.y*v.z*values[57] + 9*p.y*pow(p.z, 2)*pow(v.y, 2)*v.z*values[60] + p.y*p.z*pow(v.x, 3)*values[23] + 2*p.y*p.z*pow(v.x, 2)*v.y*values[26] + 2*p.y*p.z*pow(v.x, 2)*v.z*values[38] + 3*p.y*p.z*v.x*pow(v.y, 2)*values[29] + 4*p.y*p.z*v.x*v.y*v.z*values[41] + 3*p.y*p.z*v.x*pow(v.z, 2)*values[53] + 6*p.y*p.z*pow(v.y, 2)*v.z*values[44] + 6*p.y*p.z*v.y*pow(v.z, 2)*values[56] + p.y*pow(v.x, 3)*values[7] + 2*p.y*pow(v.x, 2)*v.y*values[10] + p.y*pow(v.x, 2)*v.z*values[22] + 3*p.y*v.x*pow(v.y, 2)*values[13] + 2*p.y*v.x*v.y*v.z*values[25] + p.y*v.x*pow(v.z, 2)*values[37] + 3*p.y*pow(v.y, 2)*v.z*values[28] + 2*p.y*v.y*pow(v.z, 2)*values[40] + p.y*pow(v.z, 3)*values[52] + pow(p.z, 3)*pow(v.x, 3)*values[51] + pow(p.z, 3)*pow(v.x, 2)*v.y*values[54] + pow(p.z, 3)*v.x*pow(v.y, 2)*values[57] + pow(p.z, 3)*pow(v.y, 3)*values[60] + pow(p.z, 2)*pow(v.x, 3)*values[35] + pow(p.z, 2)*pow(v.x, 2)*v.y*values[38] + 3*pow(p.z, 2)*pow(v.x, 2)*v.z*values[50] + pow(p.z, 2)*v.x*pow(v.y, 2)*values[41] + 3*pow(p.z, 2)*v.x*v.y*v.z*values[53] + pow(p.z, 2)*pow(v.y, 3)*values[44] + 3*pow(p.z, 2)*pow(v.y, 2)*v.z*values[56] + p.z*pow(v.x, 3)*values[19] + p.z*pow(v.x, 2)*v.y*values[22] + 2*p.z*pow(v.x, 2)*v.z*values[34] + p.z*v.x*pow(v.y, 2)*values[25] + 2*p.z*v.x*v.y*v.z*values[37] + 3*p.z*v.x*pow(v.z, 2)*values[49] + p.z*pow(v.y, 3)*values[28] + 2*p.z*pow(v.y, 2)*v.z*values[40] + 3*p.z*v.y*pow(v.z, 2)*values[52] + pow(v.x, 3)*values[3] + pow(v.x, 2)*v.y*values[6] + pow(v.x, 2)*v.z*values[18] + v.x*pow(v.y, 2)*values[9] + v.x*v.y*v.z*values[21] + v.x*pow(v.z, 2)*values[33] + pow(v.y, 3)*values[12] + pow(v.y, 2)*v.z*values[24] + v.y*pow(v.z, 2)*values[36] + pow(v.z, 3)*values[48];
    eq[4] = 3*pow(p.x, 3)*pow(p.y, 2)*v.y*pow(v.z, 3)*values[63] + 9*pow(p.x, 3)*p.y*p.z*pow(v.y, 2)*pow(v.z, 2)*values[63] + 3*pow(p.x, 3)*p.y*pow(v.y, 2)*pow(v.z, 2)*values[47] + 2*pow(p.x, 3)*p.y*v.y*pow(v.z, 3)*values[59] + 3*pow(p.x, 3)*pow(p.z, 2)*pow(v.y, 3)*v.z*values[63] + 2*pow(p.x, 3)*p.z*pow(v.y, 3)*v.z*values[47] + 3*pow(p.x, 3)*p.z*pow(v.y, 2)*pow(v.z, 2)*values[59] + pow(p.x, 3)*pow(v.y, 3)*v.z*values[31] + pow(p.x, 3)*pow(v.y, 2)*pow(v.z, 2)*values[43] + pow(p.x, 3)*v.y*pow(v.z, 3)*values[55] + 3*pow(p.x, 2)*pow(p.y, 3)*v.x*pow(v.z, 3)*values[63] + 27*pow(p.x, 2)*pow(p.y, 2)*p.z*v.x*v.y*pow(v.z, 2)*values[63] + 9*pow(p.x, 2)*pow(p.y, 2)*v.x*v.y*pow(v.z, 2)*values[47] + 3*pow(p.x, 2)*pow(p.y, 2)*v.x*pow(v.z, 3)*values[59] + 3*pow(p.x, 2)*pow(p.y, 2)*v.y*pow(v.z, 3)*values[62] + 27*pow(p.x, 2)*p.y*pow(p.z, 2)*v.x*pow(v.y, 2)*v.z*values[63] + 18*pow(p.x, 2)*p.y*p.z*v.x*pow(v.y, 2)*v.z*values[47] + 18*pow(p.x, 2)*p.y*p.z*v.x*v.y*pow(v.z, 2)*values[59] + 9*pow(p.x, 2)*p.y*p.z*pow(v.y, 2)*pow(v.z, 2)*values[62] + 9*pow(p.x, 2)*p.y*v.x*pow(v.y, 2)*v.z*values[31] + 6*pow(p.x, 2)*p.y*v.x*v.y*pow(v.z, 2)*values[43] + 3*pow(p.x, 2)*p.y*v.x*pow(v.z, 3)*values[55] + 3*pow(p.x, 2)*p.y*pow(v.y, 2)*pow(v.z, 2)*values[46] + 2*pow(p.x, 2)*p.y*v.y*pow(v.z, 3)*values[58] + 3*pow(p.x, 2)*pow(p.z, 3)*v.x*pow(v.y, 3)*values[63] + 3*pow(p.x, 2)*pow(p.z, 2)*v.x*pow(v.y, 3)*values[47] + 9*pow(p.x, 2)*pow(p.z, 2)*v.x*pow(v.y, 2)*v.z*values[59] + 3*pow(p.x, 2)*pow(p.z, 2)*pow(v.y, 3)*v.z*values[62] + 3*pow(p.x, 2)*p.z*v.x*pow(v.y, 3)*values[31] + 6*pow(p.x, 2)*p.z*v.x*pow(v.y, 2)*v.z*values[43] + 9*pow(p.x, 2)*p.z*v.x*v.y*pow(v.z, 2)*values[55] + 2*pow(p.x, 2)*p.z*pow(v.y, 3)*v.z*values[46] + 3*pow(p.x, 2)*p.z*pow(v.y, 2)*pow(v.z, 2)*values[58] + 3*pow(p.x, 2)*v.x*pow(v.y, 3)*values[15] + 3*pow(p.x, 2)*v.x*pow(v.y, 2)*v.z*values[27] + 3*pow(p.x, 2)*v.x*v.y*pow(v.z, 2)*values[39] + 3*pow(p.x, 2)*v.x*pow(v.z, 3)*values[51] + pow(p.x, 2)*pow(v.y, 3)*v.z*values[30] + pow(p.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[42] + pow(p.x, 2)*v.y*pow(v.z, 3)*values[54] + 9*p.x*pow(p.y, 3)*p.z*pow(v.x, 2)*pow(v.z, 2)*values[63] + 3*p.x*pow(p.y, 3)*pow(v.x, 2)*pow(v.z, 2)*values[47] + 2*p.x*pow(p.y, 3)*v.x*pow(v.z, 3)*values[62] + 27*p.x*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*v.y*v.z*values[63] + 18*p.x*pow(p.y, 2)*p.z*pow(v.x, 2)*v.y*v.z*values[47] + 9*p.x*pow(p.y, 2)*p.z*pow(v.x, 2)*pow(v.z, 2)*values[59] + 18*p.x*pow(p.y, 2)*p.z*v.x*v.y*pow(v.z, 2)*values[62] + 9*p.x*pow(p.y, 2)*pow(v.x, 2)*v.y*v.z*values[31] + 3*p.x*pow(p.y, 2)*pow(v.x, 2)*pow(v.z, 2)*values[43] + 6*p.x*pow(p.y, 2)*v.x*v.y*pow(v.z, 2)*values[46] + 2*p.x*pow(p.y, 2)*v.x*pow(v.z, 3)*values[58] + 3*p.x*pow(p.y, 2)*v.y*pow(v.z, 3)*values[61] + 9*p.x*p.y*pow(p.z, 3)*pow(v.x, 2)*pow(v.y, 2)*values[63] + 9*p.x*p.y*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*values[47] + 18*p.x*p.y*pow(p.z, 2)*pow(v.x, 2)*v.y*v.z*values[59] + 18*p.x*p.y*pow(p.z, 2)*v.x*pow(v.y, 2)*v.z*values[62] + 9*p.x*p.y*p.z*pow(v.x, 2)*pow(v.y, 2)*values[31] + 12*p.x*p.y*p.z*pow(v.x, 2)*v.y*v.z*values[43] + 9*p.x*p.y*p.z*pow(v.x, 2)*pow(v.z, 2)*values[55] + 12*p.x*p.y*p.z*v.x*pow(v.y, 2)*v.z*values[46] + 12*p.x*p.y*p.z*v.x*v.y*pow(v.z, 2)*values[58] + 9*p.x*p.y*p.z*pow(v.y, 2)*pow(v.z, 2)*values[61] + 9*p.x*p.y*pow(v.x, 2)*pow(v.y, 2)*values[15] + 6*p.x*p.y*pow(v.x, 2)*v.y*v.z*values[27] + 3*p.x*p.y*pow(v.x, 2)*pow(v.z, 2)*values[39] + 6*p.x*p.y*v.x*pow(v.y, 2)*v.z*values[30] + 4*p.x*p.y*v.x*v.y*pow(v.z, 2)*values[42] + 2*p.x*p.y*v.x*pow(v.z, 3)*values[54] + 3*p.x*p.y*pow(v.y, 2)*pow(v.z, 2)*values[45] + 2*p.x*p.y*v.y*pow(v.z, 3)*values[57] + 3*p.x*pow(p.z, 3)*pow(v.x, 2)*pow(v.y, 2)*values[59] + 2*p.x*pow(p.z, 3)*v.x*pow(v.y, 3)*values[62] + 3*p.x*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*values[43] + 9*p.x*pow(p.z, 2)*pow(v.x, 2)*v.y*v.z*values[55] + 2*p.x*pow(p.z, 2)*v.x*pow(v.y, 3)*values[46] + 6*p.x*pow(p.z, 2)*v.x*pow(v.y, 2)*v.z*values[58] + 3*p.x*pow(p.z, 2)*pow(v.y, 3)*v.z*values[61] + 3*p.x*p.z*pow(v.x, 2)*pow(v.y, 2)*values[27] + 6*p.x*p.z*pow(v.x, 2)*v.y*v.z*values[39] + 9*p.x*p.z*pow(v.x, 2)*pow(v.z, 2)*values[51] + 2*p.x*p.z*v.x*pow(v.y, 3)*values[30] + 4*p.x*p.z*v.x*pow(v.y, 2)*v.z*values[42] + 6*p.x*p.z*v.x*v.y*pow(v.z, 2)*values[54] + 2*p.x*p.z*pow(v.y, 3)*v.z*values[45] + 3*p.x*p.z*pow(v.y, 2)*pow(v.z, 2)*values[57] + 3*p.x*pow(v.x, 2)*pow(v.y, 2)*values[11] + 3*p.x*pow(v.x, 2)*v.y*v.z*values[23] + 3*p.x*pow(v.x, 2)*pow(v.z, 2)*values[35] + 2*p.x*v.x*pow(v.y, 3)*values[14] + 2*p.x*v.x*pow(v.y, 2)*v.z*values[26] + 2*p.x*v.x*v.y*pow(v.z, 2)*values[38] + 2*p.x*v.x*pow(v.z, 3)*values[50] + p.x*pow(v.y, 3)*v.z*values[29] + p.x*pow(v.y, 2)*pow(v.z, 2)*values[41] + p.x*v.y*pow(v.z, 3)*values[53] + 3*pow(p.y, 3)*pow(p.z, 2)*pow(v.x, 3)*v.z*values[63] + 2*pow(p.y, 3)*p.z*pow(v.x, 3)*v.z*values[47] + 3*pow(p.y, 3)*p.z*pow(v.x, 2)*pow(v.z, 2)*values[62] + pow(p.y, 3)*pow(v.x, 3)*v.z*values[31] + pow(p.y, 3)*pow(v.x, 2)*pow(v.z, 2)*values[46] + pow(p.y, 3)*v.x*pow(v.z, 3)*values[61] + 3*pow(p.y, 2)*pow(p.z, 3)*pow(v.x, 3)*v.y*values[63] + 3*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 3)*v.y*values[47] + 3*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 3)*v.z*values[59] + 9*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 2)*v.y*v.z*values[62] + 3*pow(p.y, 2)*p.z*pow(v.x, 3)*v.y*values[31] + 2*pow(p.y, 2)*p.z*pow(v.x, 3)*v.z*values[43] + 6*pow(p.y, 2)*p.z*pow(v.x, 2)*v.y*v.z*values[46] + 3*pow(p.y, 2)*p.z*pow(v.x, 2)*pow(v.z, 2)*values[58] + 9*pow(p.y, 2)*p.z*v.x*v.y*pow(v.z, 2)*values[61] + 3*pow(p.y, 2)*pow(v.x, 3)*v.y*values[15] + pow(p.y, 2)*pow(v.x, 3)*v.z*values[27] + 3*pow(p.y, 2)*pow(v.x, 2)*v.y*v.z*values[30] + pow(p.y, 2)*pow(v.x, 2)*pow(v.z, 2)*values[42] + 3*pow(p.y, 2)*v.x*v.y*pow(v.z, 2)*values[45] + pow(p.y, 2)*v.x*pow(v.z, 3)*values[57] + 3*pow(p.y, 2)*v.y*pow(v.z, 3)*values[60] + 2*p.y*pow(p.z, 3)*pow(v.x, 3)*v.y*values[59] + 3*p.y*pow(p.z, 3)*pow(v.x, 2)*pow(v.y, 2)*values[62] + 2*p.y*pow(p.z, 2)*pow(v.x, 3)*v.y*values[43] + 3*p.y*pow(p.z, 2)*pow(v.x, 3)*v.z*values[55] + 3*p.y*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*values[46] + 6*p.y*pow(p.z, 2)*pow(v.x, 2)*v.y*v.z*values[58] + 9*p.y*pow(p.z, 2)*v.x*pow(v.y, 2)*v.z*values[61] + 2*p.y*p.z*pow(v.x, 3)*v.y*values[27] + 2*p.y*p.z*pow(v.x, 3)*v.z*values[39] + 3*p.y*p.z*pow(v.x, 2)*pow(v.y, 2)*values[30] + 4*p.y*p.z*pow(v.x, 2)*v.y*v.z*values[42] + 3*p.y*p.z*pow(v.x, 2)*pow(v.z, 2)*values[54] + 6*p.y*p.z*v.x*pow(v.y, 2)*v.z*values[45] + 6*p.y*p.z*v.x*v.y*pow(v.z, 2)*values[57] + 9*p.y*p.z*pow(v.y, 2)*pow(v.z, 2)*values[60] + 2*p.y*pow(v.x, 3)*v.y*values[11] + p.y*pow(v.x, 3)*v.z*values[23] + 3*p.y*pow(v.x, 2)*pow(v.y, 2)*values[14] + 2*p.y*pow(v.x, 2)*v.y*v.z*values[26] + p.y*pow(v.x, 2)*pow(v.z, 2)*values[38] + 3*p.y*v.x*pow(v.y, 2)*v.z*values[29] + 2*p.y*v.x*v.y*pow(v.z, 2)*values[41] + p.y*v.x*pow(v.z, 3)*values[53] + 3*p.y*pow(v.y, 2)*pow(v.z, 2)*values[44] + 2*p.y*v.y*pow(v.z, 3)*values[56] + pow(p.z, 3)*pow(v.x, 3)*v.y*values[55] + pow(p.z, 3)*pow(v.x, 2)*pow(v.y, 2)*values[58] + pow(p.z, 3)*v.x*pow(v.y, 3)*values[61] + pow(p.z, 2)*pow(v.x, 3)*v.y*values[39] + 3*pow(p.z, 2)*pow(v.x, 3)*v.z*values[51] + pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*values[42] + 3*pow(p.z, 2)*pow(v.x, 2)*v.y*v.z*values[54] + pow(p.z, 2)*v.x*pow(v.y, 3)*values[45] + 3*pow(p.z, 2)*v.x*pow(v.y, 2)*v.z*values[57] + 3*pow(p.z, 2)*pow(v.y, 3)*v.z*values[60] + p.z*pow(v.x, 3)*v.y*values[23] + 2*p.z*pow(v.x, 3)*v.z*values[35] + p.z*pow(v.x, 2)*pow(v.y, 2)*values[26] + 2*p.z*pow(v.x, 2)*v.y*v.z*values[38] + 3*p.z*pow(v.x, 2)*pow(v.z, 2)*values[50] + p.z*v.x*pow(v.y, 3)*values[29] + 2*p.z*v.x*pow(v.y, 2)*v.z*values[41] + 3*p.z*v.x*v.y*pow(v.z, 2)*values[53] + 2*p.z*pow(v.y, 3)*v.z*values[44] + 3*p.z*pow(v.y, 2)*pow(v.z, 2)*values[56] + pow(v.x, 3)*v.y*values[7] + pow(v.x, 3)*v.z*values[19] + pow(v.x, 2)*pow(v.y, 2)*values[10] + pow(v.x, 2)*v.y*v.z*values[22] + pow(v.x, 2)*pow(v.z, 2)*values[34] + v.x*pow(v.y, 3)*values[13] + v.x*pow(v.y, 2)*v.z*values[25] + v.x*v.y*pow(v.z, 2)*values[37] + v.x*pow(v.z, 3)*values[49] + pow(v.y, 3)*v.z*values[28] + pow(v.y, 2)*pow(v.z, 2)*values[40] + v.y*pow(v.z, 3)*values[52];
    eq[5] = 3*pow(p.x, 3)*p.y*pow(v.y, 2)*pow(v.z, 3)*values[63] + 3*pow(p.x, 3)*p.z*pow(v.y, 3)*pow(v.z, 2)*values[63] + pow(p.x, 3)*pow(v.y, 3)*pow(v.z, 2)*values[47] + pow(p.x, 3)*pow(v.y, 2)*pow(v.z, 3)*values[59] + 9*pow(p.x, 2)*pow(p.y, 2)*v.x*v.y*pow(v.z, 3)*values[63] + 27*pow(p.x, 2)*p.y*p.z*v.x*pow(v.y, 2)*pow(v.z, 2)*values[63] + 9*pow(p.x, 2)*p.y*v.x*pow(v.y, 2)*pow(v.z, 2)*values[47] + 6*pow(p.x, 2)*p.y*v.x*v.y*pow(v.z, 3)*values[59] + 3*pow(p.x, 2)*p.y*pow(v.y, 2)*pow(v.z, 3)*values[62] + 9*pow(p.x, 2)*pow(p.z, 2)*v.x*pow(v.y, 3)*v.z*values[63] + 6*pow(p.x, 2)*p.z*v.x*pow(v.y, 3)*v.z*values[47] + 9*pow(p.x, 2)*p.z*v.x*pow(v.y, 2)*pow(v.z, 2)*values[59] + 3*pow(p.x, 2)*p.z*pow(v.y, 3)*pow(v.z, 2)*values[62] + 3*pow(p.x, 2)*v.x*pow(v.y, 3)*v.z*values[31] + 3*pow(p.x, 2)*v.x*pow(v.y, 2)*pow(v.z, 2)*values[43] + 3*pow(p.x, 2)*v.x*v.y*pow(v.z, 3)*values[55] + pow(p.x, 2)*pow(v.y, 3)*pow(v.z, 2)*values[46] + pow(p.x, 2)*pow(v.y, 2)*pow(v.z, 3)*values[58] + 3*p.x*pow(p.y, 3)*pow(v.x, 2)*pow(v.z, 3)*values[63] + 27*p.x*pow(p.y, 2)*p.z*pow(v.x, 2)*v.y*pow(v.z, 2)*values[63] + 9*p.x*pow(p.y, 2)*pow(v.x, 2)*v.y*pow(v.z, 2)*values[47] + 3*p.x*pow(p.y, 2)*pow(v.x, 2)*pow(v.z, 3)*values[59] + 6*p.x*pow(p.y, 2)*v.x*v.y*pow(v.z, 3)*values[62] + 27*p.x*p.y*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*v.z*values[63] + 18*p.x*p.y*p.z*pow(v.x, 2)*pow(v.y, 2)*v.z*values[47] + 18*p.x*p.y*p.z*pow(v.x, 2)*v.y*pow(v.z, 2)*values[59] + 18*p.x*p.y*p.z*v.x*pow(v.y, 2)*pow(v.z, 2)*values[62] + 9*p.x*p.y*pow(v.x, 2)*pow(v.y, 2)*v.z*values[31] + 6*p.x*p.y*pow(v.x, 2)*v.y*pow(v.z, 2)*values[43] + 3*p.x*p.y*pow(v.x, 2)*pow(v.z, 3)*values[55] + 6*p.x*p.y*v.x*pow(v.y, 2)*pow(v.z, 2)*values[46] + 4*p.x*p.y*v.x*v.y*pow(v.z, 3)*values[58] + 3*p.x*p.y*pow(v.y, 2)*pow(v.z, 3)*values[61] + 3*p.x*pow(p.z, 3)*pow(v.x, 2)*pow(v.y, 3)*values[63] + 3*p.x*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 3)*values[47] + 9*p.x*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*v.z*values[59] + 6*p.x*pow(p.z, 2)*v.x*pow(v.y, 3)*v.z*values[62] + 3*p.x*p.z*pow(v.x, 2)*pow(v.y, 3)*values[31] + 6*p.x*p.z*pow(v.x, 2)*pow(v.y, 2)*v.z*values[43] + 9*p.x*p.z*pow(v.x, 2)*v.y*pow(v.z, 2)*values[55] + 4*p.x*p.z*v.x*pow(v.y, 3)*v.z*values[46] + 6*p.x*p.z*v.x*pow(v.y, 2)*pow(v.z, 2)*values[58] + 3*p.x*p.z*pow(v.y, 3)*pow(v.z, 2)*values[61] + 3*p.x*pow(v.x, 2)*pow(v.y, 3)*values[15] + 3*p.x*pow(v.x, 2)*pow(v.y, 2)*v.z*values[27] + 3*p.x*pow(v.x, 2)*v.y*pow(v.z, 2)*values[39] + 3*p.x*pow(v.x, 2)*pow(v.z, 3)*values[51] + 2*p.x*v.x*pow(v.y, 3)*v.z*values[30] + 2*p.x*v.x*pow(v.y, 2)*pow(v.z, 2)*values[42] + 2*p.x*v.x*v.y*pow(v.z, 3)*values[54] + p.x*pow(v.y, 3)*pow(v.z, 2)*values[45] + p.x*pow(v.y, 2)*pow(v.z, 3)*values[57] + 3*pow(p.y, 3)*p.z*pow(v.x, 3)*pow(v.z, 2)*values[63] + pow(p.y, 3)*pow(v.x, 3)*pow(v.z, 2)*values[47] + pow(p.y, 3)*pow(v.x, 2)*pow(v.z, 3)*values[62] + 9*pow(p.y, 2)*pow(p.z, 2)*pow(v.x, 3)*v.y*v.z*values[63] + 6*pow(p.y, 2)*p.z*pow(v.x, 3)*v.y*v.z*values[47] + 3*pow(p.y, 2)*p.z*pow(v.x, 3)*pow(v.z, 2)*values[59] + 9*pow(p.y, 2)*p.z*pow(v.x, 2)*v.y*pow(v.z, 2)*values[62] + 3*pow(p.y, 2)*pow(v.x, 3)*v.y*v.z*values[31] + pow(p.y, 2)*pow(v.x, 3)*pow(v.z, 2)*values[43] + 3*pow(p.y, 2)*pow(v.x, 2)*v.y*pow(v.z, 2)*values[46] + pow(p.y, 2)*pow(v.x, 2)*pow(v.z, 3)*values[58] + 3*pow(p.y, 2)*v.x*v.y*pow(v.z, 3)*values[61] + 3*p.y*pow(p.z, 3)*pow(v.x, 3)*pow(v.y, 2)*values[63] + 3*p.y*pow(p.z, 2)*pow(v.x, 3)*pow(v.y, 2)*values[47] + 6*p.y*pow(p.z, 2)*pow(v.x, 3)*v.y*v.z*values[59] + 9*p.y*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*v.z*values[62] + 3*p.y*p.z*pow(v.x, 3)*pow(v.y, 2)*values[31] + 4*p.y*p.z*pow(v.x, 3)*v.y*v.z*values[43] + 3*p.y*p.z*pow(v.x, 3)*pow(v.z, 2)*values[55] + 6*p.y*p.z*pow(v.x, 2)*pow(v.y, 2)*v.z*values[46] + 6*p.y*p.z*pow(v.x, 2)*v.y*pow(v.z, 2)*values[58] + 9*p.y*p.z*v.x*pow(v.y, 2)*pow(v.z, 2)*values[61] + 3*p.y*pow(v.x, 3)*pow(v.y, 2)*values[15] + 2*p.y*pow(v.x, 3)*v.y*v.z*values[27] + p.y*pow(v.x, 3)*pow(v.z, 2)*values[39] + 3*p.y*pow(v.x, 2)*pow(v.y, 2)*v.z*values[30] + 2*p.y*pow(v.x, 2)*v.y*pow(v.z, 2)*values[42] + p.y*pow(v.x, 2)*pow(v.z, 3)*values[54] + 3*p.y*v.x*pow(v.y, 2)*pow(v.z, 2)*values[45] + 2*p.y*v.x*v.y*pow(v.z, 3)*values[57] + 3*p.y*pow(v.y, 2)*pow(v.z, 3)*values[60] + pow(p.z, 3)*pow(v.x, 3)*pow(v.y, 2)*values[59] + pow(p.z, 3)*pow(v.x, 2)*pow(v.y, 3)*values[62] + pow(p.z, 2)*pow(v.x, 3)*pow(v.y, 2)*values[43] + 3*pow(p.z, 2)*pow(v.x, 3)*v.y*v.z*values[55] + pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 3)*values[46] + 3*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 2)*v.z*values[58] + 3*pow(p.z, 2)*v.x*pow(v.y, 3)*v.z*values[61] + p.z*pow(v.x, 3)*pow(v.y, 2)*values[27] + 2*p.z*pow(v.x, 3)*v.y*v.z*values[39] + 3*p.z*pow(v.x, 3)*pow(v.z, 2)*values[51] + p.z*pow(v.x, 2)*pow(v.y, 3)*values[30] + 2*p.z*pow(v.x, 2)*pow(v.y, 2)*v.z*values[42] + 3*p.z*pow(v.x, 2)*v.y*pow(v.z, 2)*values[54] + 2*p.z*v.x*pow(v.y, 3)*v.z*values[45] + 3*p.z*v.x*pow(v.y, 2)*pow(v.z, 2)*values[57] + 3*p.z*pow(v.y, 3)*pow(v.z, 2)*values[60] + pow(v.x, 3)*pow(v.y, 2)*values[11] + pow(v.x, 3)*v.y*v.z*values[23] + pow(v.x, 3)*pow(v.z, 2)*values[35] + pow(v.x, 2)*pow(v.y, 3)*values[14] + pow(v.x, 2)*pow(v.y, 2)*v.z*values[26] + pow(v.x, 2)*v.y*pow(v.z, 2)*values[38] + pow(v.x, 2)*pow(v.z, 3)*values[50] + v.x*pow(v.y, 3)*v.z*values[29] + v.x*pow(v.y, 2)*pow(v.z, 2)*values[41] + v.x*v.y*pow(v.z, 3)*values[53] + pow(v.y, 3)*pow(v.z, 2)*values[44] + pow(v.y, 2)*pow(v.z, 3)*values[56];
    eq[6] = pow(p.x, 3)*pow(v.y, 3)*pow(v.z, 3)*values[63] + 9*pow(p.x, 2)*p.y*v.x*pow(v.y, 2)*pow(v.z, 3)*values[63] + 9*pow(p.x, 2)*p.z*v.x*pow(v.y, 3)*pow(v.z, 2)*values[63] + 3*pow(p.x, 2)*v.x*pow(v.y, 3)*pow(v.z, 2)*values[47] + 3*pow(p.x, 2)*v.x*pow(v.y, 2)*pow(v.z, 3)*values[59] + pow(p.x, 2)*pow(v.y, 3)*pow(v.z, 3)*values[62] + 9*p.x*pow(p.y, 2)*pow(v.x, 2)*v.y*pow(v.z, 3)*values[63] + 27*p.x*p.y*p.z*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[63] + 9*p.x*p.y*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[47] + 6*p.x*p.y*pow(v.x, 2)*v.y*pow(v.z, 3)*values[59] + 6*p.x*p.y*v.x*pow(v.y, 2)*pow(v.z, 3)*values[62] + 9*p.x*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 3)*v.z*values[63] + 6*p.x*p.z*pow(v.x, 2)*pow(v.y, 3)*v.z*values[47] + 9*p.x*p.z*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[59] + 6*p.x*p.z*v.x*pow(v.y, 3)*pow(v.z, 2)*values[62] + 3*p.x*pow(v.x, 2)*pow(v.y, 3)*v.z*values[31] + 3*p.x*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[43] + 3*p.x*pow(v.x, 2)*v.y*pow(v.z, 3)*values[55] + 2*p.x*v.x*pow(v.y, 3)*pow(v.z, 2)*values[46] + 2*p.x*v.x*pow(v.y, 2)*pow(v.z, 3)*values[58] + p.x*pow(v.y, 3)*pow(v.z, 3)*values[61] + pow(p.y, 3)*pow(v.x, 3)*pow(v.z, 3)*values[63] + 9*pow(p.y, 2)*p.z*pow(v.x, 3)*v.y*pow(v.z, 2)*values[63] + 3*pow(p.y, 2)*pow(v.x, 3)*v.y*pow(v.z, 2)*values[47] + pow(p.y, 2)*pow(v.x, 3)*pow(v.z, 3)*values[59] + 3*pow(p.y, 2)*pow(v.x, 2)*v.y*pow(v.z, 3)*values[62] + 9*p.y*pow(p.z, 2)*pow(v.x, 3)*pow(v.y, 2)*v.z*values[63] + 6*p.y*p.z*pow(v.x, 3)*pow(v.y, 2)*v.z*values[47] + 6*p.y*p.z*pow(v.x, 3)*v.y*pow(v.z, 2)*values[59] + 9*p.y*p.z*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[62] + 3*p.y*pow(v.x, 3)*pow(v.y, 2)*v.z*values[31] + 2*p.y*pow(v.x, 3)*v.y*pow(v.z, 2)*values[43] + p.y*pow(v.x, 3)*pow(v.z, 3)*values[55] + 3*p.y*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[46] + 2*p.y*pow(v.x, 2)*v.y*pow(v.z, 3)*values[58] + 3*p.y*v.x*pow(v.y, 2)*pow(v.z, 3)*values[61] + pow(p.z, 3)*pow(v.x, 3)*pow(v.y, 3)*values[63] + pow(p.z, 2)*pow(v.x, 3)*pow(v.y, 3)*values[47] + 3*pow(p.z, 2)*pow(v.x, 3)*pow(v.y, 2)*v.z*values[59] + 3*pow(p.z, 2)*pow(v.x, 2)*pow(v.y, 3)*v.z*values[62] + p.z*pow(v.x, 3)*pow(v.y, 3)*values[31] + 2*p.z*pow(v.x, 3)*pow(v.y, 2)*v.z*values[43] + 3*p.z*pow(v.x, 3)*v.y*pow(v.z, 2)*values[55] + 2*p.z*pow(v.x, 2)*pow(v.y, 3)*v.z*values[46] + 3*p.z*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[58] + 3*p.z*v.x*pow(v.y, 3)*pow(v.z, 2)*values[61] + pow(v.x, 3)*pow(v.y, 3)*values[15] + pow(v.x, 3)*pow(v.y, 2)*v.z*values[27] + pow(v.x, 3)*v.y*pow(v.z, 2)*values[39] + pow(v.x, 3)*pow(v.z, 3)*values[51] + pow(v.x, 2)*pow(v.y, 3)*v.z*values[30] + pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 2)*values[42] + pow(v.x, 2)*v.y*pow(v.z, 3)*values[54] + v.x*pow(v.y, 3)*pow(v.z, 2)*values[45] + v.x*pow(v.y, 2)*pow(v.z, 3)*values[57] + pow(v.y, 3)*pow(v.z, 3)*values[60];
    eq[7] = 3*pow(p.x, 2)*v.x*pow(v.y, 3)*pow(v.z, 3)*values[63] + 9*p.x*p.y*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 3)*values[63] + 9*p.x*p.z*pow(v.x, 2)*pow(v.y, 3)*pow(v.z, 2)*values[63] + 3*p.x*pow(v.x, 2)*pow(v.y, 3)*pow(v.z, 2)*values[47] + 3*p.x*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 3)*values[59] + 2*p.x*v.x*pow(v.y, 3)*pow(v.z, 3)*values[62] + 3*pow(p.y, 2)*pow(v.x, 3)*v.y*pow(v.z, 3)*values[63] + 9*p.y*p.z*pow(v.x, 3)*pow(v.y, 2)*pow(v.z, 2)*values[63] + 3*p.y*pow(v.x, 3)*pow(v.y, 2)*pow(v.z, 2)*values[47] + 2*p.y*pow(v.x, 3)*v.y*pow(v.z, 3)*values[59] + 3*p.y*pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 3)*values[62] + 3*pow(p.z, 2)*pow(v.x, 3)*pow(v.y, 3)*v.z*values[63] + 2*p.z*pow(v.x, 3)*pow(v.y, 3)*v.z*values[47] + 3*p.z*pow(v.x, 3)*pow(v.y, 2)*pow(v.z, 2)*values[59] + 3*p.z*pow(v.x, 2)*pow(v.y, 3)*pow(v.z, 2)*values[62] + pow(v.x, 3)*pow(v.y, 3)*v.z*values[31] + pow(v.x, 3)*pow(v.y, 2)*pow(v.z, 2)*values[43] + pow(v.x, 3)*v.y*pow(v.z, 3)*values[55] + pow(v.x, 2)*pow(v.y, 3)*pow(v.z, 2)*values[46] + pow(v.x, 2)*pow(v.y, 2)*pow(v.z, 3)*values[58] + v.x*pow(v.y, 3)*pow(v.z, 3)*values[61];
    eq[8] = 3*p.x*pow(v.x, 2)*pow(v.y, 3)*pow(v.z, 3)*values[63] + 3*p.y*pow(v.x, 3)*pow(v.y, 2)*pow(v.z, 3)*values[63] + 3*p.z*pow(v.x, 3)*pow(v.y, 3)*pow(v.z, 2)*values[63] + pow(v.x, 3)*pow(v.y, 3)*pow(v.z, 2)*values[47] + pow(v.x, 3)*pow(v.y, 2)*pow(v.z, 3)*values[59] + pow(v.x, 2)*pow(v.y, 3)*pow(v.z, 3)*values[62];
    eq[9] = pow(v.x, 3)*pow(v.y, 3)*pow(v.z, 3)*values[63];

    float[MAX_DEGREE+1] results;
    find_roots(results, eq, leaf_t_in, leaf_t_out);
    for (int i = 0; i < MAX_DEGREE; ++i)
    {
        vec3 intersectionPoint = p + v * results[i];
        if (isInsideNode(intersectionPoint, vec3(0.0), vec3(1.0))) {
            result = o + dir * results[i];
            return true;
        }
    }

    return false;
#endif
}
#endif

#if defined(SPHERE_MARCHING)
// Raycast using ray marching
bool sphereMarching(vec3 startPos, vec3 dir, float tmax, out vec3 resultPos)
{
    float accDistance = 0.0;
    vec3 pos = startPos;
    float lastDistance = 1e8;
    uint it = 0;
    while (lastDistance > epsilon && accDistance < tmax && it < maxIterations)
    {
        resultPos = pos;
        lastDistance = map(pos);
        float dist = max(lastDistance, 0.0);
        accDistance += dist;
        pos += dir * dist;
        it += 1;
    }
    return lastDistance < epsilon;
}
#endif

#ifdef SPHERE_MARCHING_SOLVER
bool sphereMarching(vec3 startPos, vec3 dir, float tmax, out vec3 resultPos)
{
    float accDistance = 0.0;
    vec3 pos = startPos;
    float lastDistance = 1e8;
    uint it = 0;

    vec3 leafPos;
    float leafSize;
    vec3 fracPart;

    while (lastDistance > epsilon && accDistance < tmax && it < maxIterations)
    {
        resultPos = pos;

        uint leafNode = getLeaf(pos, leafPos, leafSize, fracPart);
        if(bool(leafNode & isMarkedMask))
        {
            vec3 solverPos;
            float t_int = rayLeafIntersection(leafPos + leafSize, leafPos, pos, -1.0/dir);
            if(solvePolynomialEquation(pos - dir * 1e-4, dir, leafNode, leafPos, leafSize, solverPos))
            {
                resultPos = solverPos;
                return true;
            }
        }

        if(bool(leafNode & isLeafMask))
        {
            lastDistance = distanceScale * evalNode(leafNode & childrenIndexMask, fracPart);
            float t_int = rayLeafIntersection(leafPos + leafSize, leafPos, pos, 1.0/dir);
            if(lastDistance > 0) lastDistance = max(lastDistance, t_int + epsilon);
        }
        else
        {
            vec3 q = abs(pos - vec3(0.5)) - 0.5;
            lastDistance =  distanceScale * (length(max(q, vec3(0.0)))/distanceScale + minBorderValue);
        }

        float dist = max(lastDistance, 0.0);
        accDistance += dist;
        pos += dir * dist;
        it += 1;
    }
    return lastDistance < epsilon;
}
#endif

#if defined(OCTREE_TRAVERSAL_AND_SH) || defined(OCTREE_TRAVERSAL_AND_SOLVER)
bool octreeRayCast(vec3 o, vec3 dir, float far, out vec3 result)
{
    vec3 dir_inv = vec3(1/dir.x, 1/dir.y, 1/dir.z);
    float t_in;
    float t_out;
    bool intersect = raySlabIntersection(vec3(0), vec3(1), o, dir_inv, t_in, t_out);
    if (t_out < 0) return false;
    //intersect bounding box first, if no intersection return false automatically
    if (!intersect) return false;
    
    //works until here
    float t_end = min(t_out, far);

    vec3 leafPos;
    float leafSize;
    vec3 fracPart;

    float t = max(0, t_in) + epsilon;

    while (t >= 0 && t <= t_end)
    {
        // Get leaf
        uint leafNode = getLeaf(o + dir * t, leafPos, leafSize, fracPart); //problem is here maybe?

        vec3 leafBBmax = leafPos + leafSize;
        vec3 leafBBmin = leafPos;
        
        float t_int = rayLeafIntersection(leafBBmax, leafBBmin, o + dir * t, dir_inv);

        if (bool(leafNode & isMarkedMask)) // Is a leaf node
        {
            if(solvePolynomialEquation(o + dir * (t - epsilon), dir, leafNode, leafPos, leafSize, result)) return true;
        }

        t += t_int + epsilon; // Ensure to move to the next node
    }

    return false;    
}
#endif

bool raycast(vec3 ro, vec3 rd, float far)
{
    vec3 hitPoint;
    #if defined(SPHERE_MARCHING) || defined(SPHERE_MARCHING_SOLVER)
    return sphereMarching(ro, rd, far, hitPoint);
    #endif
    #if defined(OCTREE_TRAVERSAL_AND_SH) || defined(OCTREE_TRAVERSAL_AND_SOLVER)
    return octreeRayCast(ro, rd, far, hitPoint);
    #endif
}

//New main
void main()
{
    //Get pixel coord
    uvec2 pCoord = gl_GlobalInvocationID.xy;
    vec3 pixelPos = vec3((vec2(pCoord) + vec2(0.5)) * pixelToView - nearPlaneHalfSize, -nearAndFarPlane.x);

    //Get world position and direction
    vec3 worldPos = vec3(invViewModelMatrix * vec4(vec3(0.0), 1.0));
    vec3 worldDir = normalize(vec3(invViewModelMatrix * vec4(pixelPos, 1.0)) - worldPos);

    //Background colour
    vec3 outColor = vec3(0.9);

    vec3 hitPoint;
    #if defined(SPHERE_MARCHING) || defined(SPHERE_MARCHING_SOLVER)
    if(sphereMarching(worldPos, worldDir, nearAndFarPlane.y, hitPoint))
    #endif
    #if defined(OCTREE_TRAVERSAL_AND_SH) || defined(OCTREE_TRAVERSAL_AND_SOLVER)
    if(octreeRayCast(worldPos, worldDir, nearAndFarPlane.y, hitPoint))
    #endif
    {
        outColor = mapColor(hitPoint, worldPos);
    }

    //Store the rendered image to output texture to later display in a quad
    imageStore(outputTexture, ivec2(pCoord), vec4(outColor, 1.0));
}