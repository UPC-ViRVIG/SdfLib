// Algorithm configuration
// #define USE_TRILINEAR_INTERPOLATION
// #define USE_TRICUBIC_INTERPOLATION
// #define TRICUBIC_NORMALS
// #define SPHERE_MARCHING
// #define SPHERE_MARCHING_SOLVER
// #define OCTREE_TRAVERSAL_AND_SH
// #define OCTREE_TRAVERSAL_AND_SOLVER

#define MAX_AO_ITERATIONS 8
#define NEWTON_ITER 1
#define HALLEY_ITER 1
#define M_PI 3.14159265358979323846

layout (local_size_x = 16, local_size_y = 16) in;

layout(rgba32f, binding = 0) uniform image2D outputTexture;

uniform vec3 startGridSize;

layout(std430, binding = 3) buffer octree
{
    uint octreeData[];
};

layout(std430, binding = 4) buffer octree2
{
    vec4 octreeValues[];
};

// #ifdef TRICUBIC_GRADIENTS
// layout(std430, binding = 2) buffer octreeTricubic
// {
//     uint octreeTricubicData[];
// };
// #endif

const uint isLeafMask = 1 << 31;
const uint isMarkedMask = 1 << 30;
const uint childrenIndexMask = ~(isLeafMask | isMarkedMask);

uint roundFloat(float a)
{
    return (a >= 0.5) ? 1 : 0;
}

uniform vec2 pixelToView;
uniform vec2 nearPlaneHalfSize;
uniform vec2 nearAndFarPlane;
uniform mat4 invViewModelMatrix;
uniform float distanceScale;
uniform float minBorderValue;
uniform float epsilon; // Could be removed

//Options
uniform int maxIterations; // Could be removed
uniform int maxShadowIterations; // Could be removed

uniform bool useAO;

uniform bool useShadows;
uniform bool useSoftShadows; // Could be removed

//Lighting
uniform int lightNumber;
uniform vec3 lightPos[4];
uniform float lightIntensity[4];
uniform vec3 lightColor[4];
uniform float lightRadius[4];

//Material
uniform float matMetallic;
uniform float matRoughness;
uniform vec3 matAlbedo;
uniform vec3 matF0;

/// --- Utils --- ///
float sphereSDF(vec3 samplePoint, float radius) {
    return length(samplePoint) - radius;
}

float opSmoothIntersection( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) + k*h*(1.0-h); 
}

mat4 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);

    return mat4(
        vec4(1, 0, 0, 0),
        vec4(0, c, -s, 0),
        vec4(0, s, c, 0),
        vec4(0, 0, 0, 1)
    );
}

mat4 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);

    return mat4(
        vec4(c, 0, s, 0),
        vec4(0, 1, 0, 0),
        vec4(-s, 0, c, 0),
        vec4(0, 0, 0, 1)
    );
}

mat4 rotateZ(float theta) {
    float c = cos(theta);
    float s = sin(theta);

    return mat4(
        vec4(c, -s, 0, 0),
        vec4(s, c, 0, 0),
        vec4(0, 0, 1, 0),
        vec4(0, 0, 0, 1)
    );
}

vec3 rotate(vec3 p, vec3 rot) 
{
    mat4 rotX = inverse(rotateX(rot.x));
    mat4 rotY = inverse(rotateY(rot.y));
    mat4 rotZ = inverse(rotateZ(rot.z));

    return (rotZ * rotY * rotX * vec4(p, 1)).xyz;
}  

const float pos_infinity = uintBitsToFloat(0x7F800000);
const float neg_infinity = uintBitsToFloat(0xFF800000);

//Ray slab intersection
bool raySlabIntersection(vec3 bbmin, vec3 bbmax, vec3 o, vec3 d_inv, out float tmin, out float tmax) {
    
    tmin = neg_infinity;
    tmax = pos_infinity;

    //x
    float tx1 = (bbmin.x - o.x) * d_inv.x;
    float tx2 = (bbmax.x - o.x) * d_inv.x;

    tmin = max(tmin, min(tx1, tx2));
    tmax = min(tmax, max(tx1, tx2));

    //y
    float ty1 = (bbmin.y - o.y) * d_inv.y;
    float ty2 = (bbmax.y - o.y) * d_inv.y;

    tmin = max(tmin, min(ty1, ty2));
    tmax = min(tmax, max(ty1, ty2));

    //z
    float tz1 = (bbmin.z - o.z) * d_inv.z;
    float tz2 = (bbmax.z - o.z) * d_inv.z;

    tmin = max(tmin, min(tz1, tz2));
    tmax = min(tmax, max(tz1, tz2));

    return tmax >= tmin;
}

float rayLeafIntersection(vec3 bbmax, vec3 bbmin, vec3 o, vec3 d_inv) {
    float tx = (((d_inv.x > 0) ? bbmax.x : bbmin.x) - o.x) * d_inv.x;
    float ty = (((d_inv.y > 0) ? bbmax.y : bbmin.y) - o.y) * d_inv.y;
    float tz = (((d_inv.z > 0) ? bbmax.z : bbmin.z) - o.z) * d_inv.z;

    if (tx < 0) tx = 1e8;
    if (ty < 0) ty = 1e8;
    if (tz < 0) tz = 1e8;
    return min(tx, min(ty, tz));
}

// Light utils functions
vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH  = max(dot(N, H), 0.0);
    float NdotH2 = NdotH*NdotH;
	
    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = M_PI * denom * denom;
	
    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float num   = NdotV;
    float denom = NdotV * (1.0 - k) + k;
	
    return num / denom;
}
float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2  = GeometrySchlickGGX(NdotV, roughness);
    float ggx1  = GeometrySchlickGGX(NdotL, roughness);
	
    return ggx1 * ggx2;
}

/// --- Access to the sdfOctree --- ///
bool isOutsideGrid(vec3 point) 
{
    vec3 fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));

    return arrayPos.x < 0 || arrayPos.y < 0 || arrayPos.z < 0 ||
       arrayPos.x >= startGridSize.x || arrayPos.y >= startGridSize.y || arrayPos.z >= startGridSize.z;
}

uint getLeaf(vec3 point, out vec3 leafPos, out float leafSize, out vec3 fracPart) 
{
    fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));

    #if defined(SPHERE_MARCHING_SOLVER) || defined(SPHERE_MARCHING)
    if(arrayPos.x < 0 || arrayPos.y < 0 || arrayPos.z < 0 ||
       arrayPos.x >= startGridSize.x || arrayPos.y >= startGridSize.y || arrayPos.z >= startGridSize.z)
    {
        return 0;
    }
    #endif

    fracPart = fract(fracPart);

    int index = arrayPos.z * int(startGridSize.y * startGridSize.x) +
                arrayPos.y * int(startGridSize.x) +
                arrayPos.x;
    uint currentNode = octreeData[index];

    leafSize = 1.0/startGridSize.x;
    leafPos = vec3(arrayPos)/startGridSize;
    while(!bool(currentNode & isLeafMask))
    {
        uvec3 childPos = uvec3(roundFloat(fracPart.x), roundFloat(fracPart.y), roundFloat(fracPart.z));
        uint childIdx = (childPos.z << 2) +
                        (childPos.y << 1) +
                         childPos.x;

        currentNode = octreeData[(currentNode & childrenIndexMask) + childIdx];
        fracPart = fract(2.0 * fracPart);
        leafSize *= 0.5;
        leafPos = leafPos + vec3(childPos) * leafSize;
    }

    return currentNode;
}

void getPolynomial(uint currentNode, out float array[8]) 
{
    uint vIndex = currentNode & childrenIndexMask;
    array[0] = uintBitsToFloat(octreeData[vIndex]);
    array[1] = uintBitsToFloat(octreeData[vIndex + 1]);
    array[2] = uintBitsToFloat(octreeData[vIndex + 2]);
    array[3] = uintBitsToFloat(octreeData[vIndex + 3]);
    array[4] = uintBitsToFloat(octreeData[vIndex + 4]);
    array[5] = uintBitsToFloat(octreeData[vIndex + 5]);
    array[6] = uintBitsToFloat(octreeData[vIndex + 6]);
    array[7] = uintBitsToFloat(octreeData[vIndex + 7]);
    return;
}

float evalNode(uint vIndex, vec3 fracPart)
{
#ifdef USE_TRILINEAR_INTERPOLATION
    // float d00 = uintBitsToFloat(octreeData[vIndex]) * (1.0f - fracPart.x) +
    //             uintBitsToFloat(octreeData[vIndex + 1]) * fracPart.x;
    // float d01 = uintBitsToFloat(octreeData[vIndex + 2]) * (1.0f - fracPart.x) +
    //             uintBitsToFloat(octreeData[vIndex + 3]) * fracPart.x;
    // float d10 = uintBitsToFloat(octreeData[vIndex + 4]) * (1.0f - fracPart.x) +
    //             uintBitsToFloat(octreeData[vIndex + 5]) * fracPart.x;
    // float d11 = uintBitsToFloat(octreeData[vIndex + 6]) * (1.0f - fracPart.x) +
    //             uintBitsToFloat(octreeData[vIndex + 7]) * fracPart.x;

    // float d0 = d00 * (1.0f - fracPart.y) + d01 * fracPart.y;
    // float d1 = d10 * (1.0f - fracPart.y) + d11 * fracPart.y;

    // return d0 * (1.0f - fracPart.z) + d1 * fracPart.z;

    vec4 v1 = octreeValues[vIndex];
    vec4 v2 = octreeValues[vIndex+1];

    vec4 d = v1 + fracPart.x * v2;
    vec2 f = d.xz + fracPart.y * d.yw;
    return f.x + fracPart.z * f.y;

    // float d00 = v1.x * (1.0f - fracPart.x) +
    //             v1.y * fracPart.x;
    // float d01 = v1.z * (1.0f - fracPart.x) +
    //             v1.w * fracPart.x;
    // float d10 = v2.x * (1.0f - fracPart.x) +
    //             v2.y * fracPart.x;
    // float d11 = v2.z * (1.0f - fracPart.x) +
    //             v2.w * fracPart.x;

    // float d0 = d00 * (1.0f - fracPart.y) + d01 * fracPart.y;
    // float d1 = d10 * (1.0f - fracPart.y) + d11 * fracPart.y;

    // return d0 * (1.0f - fracPart.z) + d1 * fracPart.z;
#endif

#ifdef USE_TRICUBIC_INTERPOLATION
    // return 0.0
    //      + uintBitsToFloat(octreeData[vIndex + 0]) + uintBitsToFloat(octreeData[vIndex + 1]) * fracPart[0] + uintBitsToFloat(octreeData[vIndex + 2]) * fracPart[0] * fracPart[0] + uintBitsToFloat(octreeData[vIndex + 3]) * fracPart[0] * fracPart[0] * fracPart[0] + uintBitsToFloat(octreeData[vIndex + 4]) * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 5]) * fracPart[0] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 6]) * fracPart[0] * fracPart[0] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 7]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 8]) * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 9]) * fracPart[0] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 10]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 11]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 12]) * fracPart[1] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 13]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 14]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + uintBitsToFloat(octreeData[vIndex + 15]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
    //      + uintBitsToFloat(octreeData[vIndex + 16]) * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 17]) * fracPart[0] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 18]) * fracPart[0] * fracPart[0] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 19]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 20]) * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[0] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 24]) * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 28]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
    //      + uintBitsToFloat(octreeData[vIndex + 32]) * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 33]) * fracPart[0] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 34]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 35]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 36]) * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 40]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 44]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
    //      + uintBitsToFloat(octreeData[vIndex + 48]) * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 49]) * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 50]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 51]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 52]) * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 56]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 60]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2];

    vec4 vz = vec4(fracPart.z, fracPart.z, fracPart.z, 1.0);
    vz.xy = vz.xy * fracPart.z; vz.x = vz.x * fracPart.z;

    vec4 vy = vec4(fracPart.y, fracPart.y, fracPart.y, 1.0);
    vy.xy = vy.xy * fracPart.y; vy.x = vy.x * fracPart.y;

    vec4 vx = vec4(fracPart.x, fracPart.x, fracPart.x, 1.0);
    vx.xy = vx.xy * fracPart.x; vx.x = vx.x * fracPart.x;

    vec4 rx;
    vec4 ry;
    ry.x = dot(octreeValues[vIndex + 0], vz);
    ry.y = dot(octreeValues[vIndex + 1], vz);
    ry.z = dot(octreeValues[vIndex + 2], vz);
    ry.w = dot(octreeValues[vIndex + 3], vz);
    rx.x = dot(ry, vy);

    ry.x = dot(octreeValues[vIndex + 4], vz);
    ry.y = dot(octreeValues[vIndex + 5], vz);
    ry.z = dot(octreeValues[vIndex + 6], vz);
    ry.w = dot(octreeValues[vIndex + 7], vz);
    rx.y = dot(ry, vy);

    ry.x = dot(octreeValues[vIndex + 8], vz);
    ry.y = dot(octreeValues[vIndex + 9], vz);
    ry.z = dot(octreeValues[vIndex + 10], vz);
    ry.w = dot(octreeValues[vIndex + 11], vz);
    rx.z = dot(ry, vy);

    ry.x = dot(octreeValues[vIndex + 12], vz);
    ry.y = dot(octreeValues[vIndex + 13], vz);
    ry.z = dot(octreeValues[vIndex + 14], vz);
    ry.w = dot(octreeValues[vIndex + 15], vz);
    rx.w = dot(ry, vy);

    return dot(rx, vx);
#endif
}

float getDistance(vec3 point)
{
    vec3 fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));

    if(arrayPos.x < 0 || arrayPos.y < 0 || arrayPos.z < 0 ||
       arrayPos.x >= startGridSize.x || arrayPos.y >= startGridSize.y || arrayPos.z >= startGridSize.z)
    {
            vec3 q = abs(point - vec3(0.5)) - 0.5;
            return length(max(q, vec3(0.0)))/distanceScale + minBorderValue;
    }

    fracPart = fract(fracPart);

    int index = arrayPos.z * int(startGridSize.y * startGridSize.x) +
                arrayPos.y * int(startGridSize.x) +
                arrayPos.x;
    uint currentNode = octreeData[index];

    while(!bool(currentNode & isLeafMask))
    {
        uint childIdx = (roundFloat(fracPart.z) << 2) + 
                        (roundFloat(fracPart.y) << 1) + 
                         roundFloat(fracPart.x);

        currentNode = octreeData[(currentNode & childrenIndexMask) + childIdx];
        fracPart = fract(2.0 * fracPart);
    }

    uint vIndex = currentNode & childrenIndexMask;

    return evalNode(vIndex, fracPart);
}

vec3 getGradient(vec3 point)
{
    vec3 fracPart = point * startGridSize;
    ivec3 arrayPos = ivec3(floor(fracPart));
    fracPart = fract(fracPart);
    int index = arrayPos.z * int(startGridSize.y * startGridSize.x) +
                arrayPos.y * int(startGridSize.x) +
                arrayPos.x;
    uint currentNode = octreeData[index];

    while(!bool(currentNode & isLeafMask))
    {
        uint childIdx = (roundFloat(fracPart.z) << 2) + 
                        (roundFloat(fracPart.y) << 1) + 
                         roundFloat(fracPart.x);

        currentNode = octreeData[(currentNode & childrenIndexMask) + childIdx];
        fracPart = fract(2.0 * fracPart);
    }

    uint vIndex = currentNode & childrenIndexMask;

#if defined(USE_TRILINEAR_INTERPOLATION) && !defined(TRICUBIC_NORMALS) && !defined(USE_TRICUBIC_IN_ISOSURFACE)
    vec4 v1 = octreeValues[vIndex];
    vec4 v2 = octreeValues[vIndex+1];

    vec3 g;
    vec4 d = v1 + fracPart.x * v2;
    g.y = d.y + fracPart.z * d.w;
    g.z = d.z + fracPart.y * d.w;
    vec2 f = v2.xz + fracPart.y * v2.yw;
    g.x = f.x + fracPart.z * f.y;
    return normalize(g);

    // float gx = 0.0;
    // {               
    //     float d00 = v1.x * (1.0f - fracPart.y) +
    //                 v1.z * fracPart.y;
    //     float d01 = v1.y * (1.0f - fracPart.y) +
    //                 v1.w * fracPart.y;
    //     float d10 = v2.x * (1.0f - fracPart.y) +
    //                 v2.z * fracPart.y;
    //     float d11 = v2.y * (1.0f - fracPart.y) +
    //                 v2.w * fracPart.y;

    //     float d0 = d00 * (1.0f - fracPart.z) + d10 * fracPart.z;
    //     float d1 = d01 * (1.0f - fracPart.z) + d11 * fracPart.z;

    //     gx = d1 - d0;
    // }

    // float gy = 0.0;
    // float gz = 0.0;
    // {
    //     float d00 = v1.x * (1.0f - fracPart.x) +
    //                 v1.y * fracPart.x;
    //     float d01 = v1.z * (1.0f - fracPart.x) +
    //                 v1.w * fracPart.x;
    //     float d10 = v2.x * (1.0f - fracPart.x) +
    //                 v2.y * fracPart.x;
    //     float d11 = v2.z * (1.0f - fracPart.x) +
    //                 v2.w * fracPart.x;

    //     {
    //         float d0 = d00 * (1.0f - fracPart.z) + d10 * fracPart.z;
    //         float d1 = d01 * (1.0f - fracPart.z) + d11 * fracPart.z;

    //         gy = d1 - d0;
    //     }

    //     {
    //         float d0 = d00 * (1.0f - fracPart.y) + d01 * fracPart.y;
    //         float d1 = d10 * (1.0f - fracPart.y) + d11 * fracPart.y;

    //         gz = d1 - d0;
    //     }
    // }

    // return normalize(vec3(gx, gy, gz));
#endif

#if defined(USE_TRICUBIC_INTERPOLATION) || defined(TRICUBIC_NORMALS) || defined(USE_TRICUBIC_IN_ISOSURFACE)
    // return normalize(vec3((1 * uintBitsToFloat(octreeData[vIndex + 1]) + 2 * uintBitsToFloat(octreeData[vIndex + 2]) * fracPart[0] + 3 * uintBitsToFloat(octreeData[vIndex + 3]) * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 5]) * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 6]) * fracPart[0] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 7]) * fracPart[0] * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 9]) * fracPart[1] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 10]) * fracPart[0] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 11]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 13]) * fracPart[1] * fracPart[1] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 14]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 15]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
    //     + 1 * uintBitsToFloat(octreeData[vIndex + 17]) * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 18]) * fracPart[0] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 19]) * fracPart[0] * fracPart[0] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
    //     + 1 * uintBitsToFloat(octreeData[vIndex + 33]) * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 34]) * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 35]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
    //     + 1 * uintBitsToFloat(octreeData[vIndex + 49]) * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 50]) * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 51]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2]),
    //     (1 * uintBitsToFloat(octreeData[vIndex + 4]) + 1 * uintBitsToFloat(octreeData[vIndex + 5]) * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 6]) * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 7]) * fracPart[0] * fracPart[0] * fracPart[0] + 2 * uintBitsToFloat(octreeData[vIndex + 8]) * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 9]) * fracPart[0] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 10]) * fracPart[0] * fracPart[0] * fracPart[1] + 2 * uintBitsToFloat(octreeData[vIndex + 11]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 12]) * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 13]) * fracPart[0] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 14]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 3 * uintBitsToFloat(octreeData[vIndex + 15]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1]
    //     + 1 * uintBitsToFloat(octreeData[vIndex + 20]) * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[0] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[0] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 24]) * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 28]) * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2]
    //     + 1 * uintBitsToFloat(octreeData[vIndex + 36]) * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[0] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 40]) * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 44]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2]
    //     + 1 * uintBitsToFloat(octreeData[vIndex + 52]) * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 1 * uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 56]) * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 60]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] * fracPart[2]),
    //     (1 * uintBitsToFloat(octreeData[vIndex + 16]) + 1 * uintBitsToFloat(octreeData[vIndex + 17]) * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 18]) * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 19]) * fracPart[0] * fracPart[0] * fracPart[0] + 1 * uintBitsToFloat(octreeData[vIndex + 20]) * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 21]) * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 22]) * fracPart[0] * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 23]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 24]) * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 25]) * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 26]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 27]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 28]) * fracPart[1] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 29]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 30]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] + 1 * uintBitsToFloat(octreeData[vIndex + 31]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1]
    //     + 2 * uintBitsToFloat(octreeData[vIndex + 32]) * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 33]) * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 34]) * fracPart[0] * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 35]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 36]) * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 37]) * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 38]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 39]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 40]) * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 41]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 42]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 43]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 44]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 45]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 46]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] + 2 * uintBitsToFloat(octreeData[vIndex + 47]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2]
    //     + 3 * uintBitsToFloat(octreeData[vIndex + 48]) * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 49]) * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 50]) * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 51]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 52]) * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 53]) * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 54]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 55]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 56]) * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 57]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 58]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 59]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 60]) * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 61]) * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 62]) * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2] + 3 * uintBitsToFloat(octreeData[vIndex + 63]) * fracPart[0] * fracPart[0] * fracPart[0] * fracPart[1] * fracPart[1] * fracPart[1] * fracPart[2] * fracPart[2])
    // ));

#ifdef TRICUBIC_NORMALS
    vIndex += 2;
#endif

    vec4 vz = vec4(fracPart.z, fracPart.z, fracPart.z, 1.0);
    vz.xy = vz.xy * fracPart.z; vz.x = vz.x * fracPart.z;
    vec4 dz = vec4(3.0 * fracPart.z * fracPart.z, 2.0 * fracPart.z, 1.0, 0.0);

    vec4 vy = vec4(fracPart.y, fracPart.y, fracPart.y, 1.0);
    vy.xy = vy.xy * fracPart.y; vy.x = vy.x * fracPart.y;
    vec4 dy = vec4(3.0 * fracPart.y * fracPart.y, 2.0 * fracPart.y, 1.0, 0.0);

    vec4 vx = vec4(fracPart.x, fracPart.x, fracPart.x, 1.0);
    vx.xy = vx.xy * fracPart.x; vx.x = vx.x * fracPart.x;

    vec4 tmp;
    vec4 rx;
    vec4 ry, ry1;
    vec3 res;
    tmp = octreeValues[vIndex + 0];
    ry.x = dot(tmp, vz);
    ry1.x = dot(tmp, dz);
    tmp = octreeValues[vIndex + 1];
    ry.y = dot(tmp, vz);
    ry1.y = dot(tmp, dz);
    tmp = octreeValues[vIndex + 2];
    ry.z = dot(tmp, vz);
    ry1.z = dot(tmp, dz);
    tmp = octreeValues[vIndex + 3];
    ry.w = dot(tmp, vz);
    ry1.w = dot(tmp, dz);

    res.yz = vx.x * vec2(dot(dy, ry), dot(ry1, vy));
    rx.x = dot(ry, vy);

    tmp = octreeValues[vIndex + 4];
    ry.x = dot(tmp, vz);
    ry1.x = dot(tmp, dz);
    tmp = octreeValues[vIndex + 5];
    ry.y = dot(tmp, vz);
    ry1.y = dot(tmp, dz);
    tmp = octreeValues[vIndex + 6];
    ry.z = dot(tmp, vz);
    ry1.z = dot(tmp, dz);
    tmp = octreeValues[vIndex + 7];
    ry.w = dot(tmp, vz);
    ry1.w = dot(tmp, dz);

    res.yz += vx.y * vec2(dot(dy, ry), dot(ry1, vy));
    rx.y = dot(ry, vy);

    tmp = octreeValues[vIndex + 8];
    ry.x = dot(tmp, vz);
    ry1.x = dot(tmp, dz);
    tmp = octreeValues[vIndex + 9];
    ry.y = dot(tmp, vz);
    ry1.y = dot(tmp, dz);
    tmp = octreeValues[vIndex + 10];
    ry.z = dot(tmp, vz);
    ry1.z = dot(tmp, dz);
    tmp = octreeValues[vIndex + 11];
    ry.w = dot(tmp, vz);
    ry1.w = dot(tmp, dz);

    res.yz += vx.z * vec2(dot(dy, ry), dot(ry1, vy));
    rx.z = dot(ry, vy);

    tmp = octreeValues[vIndex + 12];
    ry.x = dot(tmp, vz);
    ry1.x = dot(tmp, dz);
    tmp = octreeValues[vIndex + 13];
    ry.y = dot(tmp, vz);
    ry1.y = dot(tmp, dz);
    tmp = octreeValues[vIndex + 14];
    ry.z = dot(tmp, vz);
    ry1.z = dot(tmp, dz);
    tmp = octreeValues[vIndex + 15];
    ry.w = dot(tmp, vz);
    ry1.w = dot(tmp, dz);

    res.yz += vx.w * vec2(dot(dy, ry), dot(ry1, vy));
    rx.w = dot(ry, vy);

    res.x = dot(rx, vec4(3.0 * fracPart.x * fracPart.x, 2.0 * fracPart.x, 1.0, 0.0));

    return normalize(res);
#endif
}

/// --- Scene --- ///
float map(vec3 pos)
{
    return distanceScale * getDistance(pos);
}

//Gradient of the scene
vec3 mapGradient(vec3 pos)
{
    // Get the exact gradient
    return getGradient(pos);

    // Get an approximation of the gradient
    // float dist = mapTri(pos);
    // return normalize(vec3(
    //     mapTri(pos + vec3(epsilon, 0, 0)) - dist,
    //     mapTri(pos + vec3(0, epsilon, 0)) - dist,
    //     mapTri(pos + vec3(0, 0, epsilon)) - dist
    // ));
}

/// --- Lighthing --- ///

#ifdef SPHERE_MARCHING
float getAO(vec3 pos, vec3 n)
{
    float occ = 0.0;
    float decay = 1.0;
    for(int i=0; i < MAX_AO_ITERATIONS; i++)
    {
        float h = 0.002 + 0.1 * float(i)/8.0;
        float d = map(pos + n * h);
        occ += max(h-d, 0.0);
        decay *= 0.8;
    }

    return min(1.0 - 1.5 * occ, 1.0);
}
#endif

// float hardshadow(in vec3 ro, in vec3 rd)
// {
//     vec3 result;
//     if (raymarchV3(ro, rd, result)) return 0.0;
//     return 1.0;
// }

// //Inigo Quilez improved soft shadow
// float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w )
// {
//     float res = 1.0;
//     float t = mint;
//     for( int i=0; i<maxShadowIterations && t<maxt; i++ )
//     {
//         float h = distanceScale * getDistanceTricubic(ro + t*rd);
//         res = min( res, h/(w*t) );
//         t += clamp(h, 0.005, 0.50);
//         if( res<-1.0 || t>maxt ) break;
//     }
//     res = max(res,-1.0);
//     return 0.25*(1.0+res)*(1.0+res)*(2.0-res);
// }

float softshadowToPoint(vec3 startPos, vec3 dir, float tmax)
{
    float accDistance = 0.0;
    vec3 pos = startPos;
    float lastDistance = 1e8;
    uint it = 0;
    float res = 1.0;
    while (accDistance < tmax && it < maxIterations)
    {
        lastDistance = map(pos);
        if(lastDistance < epsilon) return 0.0;
        float dist = max(lastDistance, 0.0);
        accDistance += dist;
        res = min(res, dist/accDistance);
        pos += dir * dist;
        it += 1;
    }

    return res;
}

bool raycast(vec3 ro, vec3 rd, float far);

//hard shadows using v3
float shadow(vec3 ro, vec3 rd, float far, float coneAngle)
{
    #ifdef SPHERE_MARCHING
    return min(atan(softshadowToPoint(ro, rd, far)) / coneAngle, 1.0);
    #else
    return raycast(ro, rd, far) ? 0.0 : 1.0;
    #endif
}

// Temple
// vec3 getColor(vec3 pos, out float roughness, out float metallic)
// {
//     if(pos.y < 0.179311)
//     {
//         roughness = 0.598;
//         metallic = 0.904;
        
//         vec2 aux = floor(pos.xz * 10.0);
//         if(int(aux.x + aux.y) % 2 == 0) return vec3(0.87, 0.80, 0.70);
//         else return vec3(0.01, 0.01, 0.01);
//     }
//     else
//     {
//         vec3 ballsCenterPos = 0.5 * (vec3(-0.002249, -0.302127, 0.091567) + vec3(1.0));
//         vec3 ballsSize = 0.5 * vec3(0.283056, 0.283056, 0.283056);
//         vec3 aux = abs(pos - ballsCenterPos) - ballsSize;
//         if(aux.x < 0.0 && aux.y < 0.0 && aux.z < 0.0)
//         {
//             roughness = 1.0;
//             metallic = 0.52;
//             return vec3(0.99, 0.45, 0.0042);
//         }

//         if(pos.x < 0.5 * (0.464 + 1.0) &&
//            pos.x > 0.5 * (-0.464 + 1.0) &&
//            pos.y < 0.5 * (0.389 + 1.0))
//         {
//             roughness = 0.0;
//             metallic = 0.54;
//             return vec3(1.000, 0.1, 0.1);
//         }

//         roughness = 0.0;
//         metallic = 0.73;

//         return vec3(0.79, 0.65, 0.52);
//     }
// }

// Forest
// vec3 getColor(vec3 pos, out float roughness, out float metallic)
// {
//     if(pos.y < 0.5 * (-0.329761 + 1.0))
//     {
//         return vec3(0.53, 0.77, 0.23);
//     }
//     else
//     {
//         return vec3(0.6, 0.4, 0.20);
//     }
// }

// vec3 getColor(vec3 pos, out float roughness, out float metallic)
// {
//     if(pos.x > 1.0 - 0.15 ||
//        pos.y < 0.2 ||
//        pos.z < 0.15)
//     {
//         return vec3(0.98, 0.35, 0.98);
//     }
//     else
//     {
//         return vec3(20./255., 1.0, 0.95);
//     }
// }

vec3 mapColor(vec3 pos, vec3 cameraPos)
{
    //Approximate normal
    vec3 N = getGradient(pos);
    //View vector
    vec3 V = normalize(cameraPos - pos);

    // Object material
    float metallic, roughness;
    vec3 albedo, F0;
    metallic = matMetallic;
    roughness = matRoughness;
    // float v1, v2;
    // albedo = getColor(pos, v1, v2);
    albedo = matAlbedo;
    F0 = mix(matF0, albedo, metallic);
 
    vec3 Lo = vec3(0.0);

    // Directional lights
    for (int i = 0; i < lightNumber; i++) 
    {
        float distToLight = length(lightPos[i] - pos);
        vec3 L = normalize(lightPos[i] - pos);
        vec3 H = normalize(V + L);

        vec3 sunColor = lightIntensity[i] * lightColor[i];

        float coneAngle = atan(lightRadius[i]/distToLight);
        float solidAngle = M_PI * sin(coneAngle) * pow((lightRadius[i]/distToLight), 2.0);
        // float intensity = useShadows ? shadow(pos + epsilon * L, L, 0.005, distToLight, solidAngle) : 1.0f;
        float intensity = useShadows ? shadow(pos + + 0.0004 * N, L, distToLight, coneAngle) : 1.0f;
        vec3 radiance = sunColor * intensity;
        
        // Cook-torrance brdf
        float NDF = DistributionGGX(N, H, roughness);        
        float G = GeometrySmith(N, V, L, roughness);      
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);       
        
        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= 1.0 - metallic;	  
        
        vec3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 1e-4;
        vec3 specular = numerator / denominator;  
            
        // Add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);                
        Lo += (kD * albedo / M_PI + specular) * radiance * NdotL;
    }

    #if defined(SPHERE_MARCHING)
    vec3 ambient = useAO ? vec3(0.5) * albedo * getAO(pos, N) : vec3(0.5) * albedo; // Ambient light estimation
    #else
    vec3 ambient = vec3(0.5) * albedo; // Ambient light estimation
    #endif

    vec3 color = ambient + Lo;

    color = color / (color + vec3(1.0));
    color = pow(color, vec3(1.0/2.2));  
   
    return color;
}

/// --- RAY MARCHING ALGORITHM --- ///

bool isInsideNode(vec3 p, vec3 cubeMin, vec3 cubeMax)
{
    bool insideX, insideY, insideZ;
    insideX = p.x >= cubeMin.x && p.x <= cubeMax.x;
    insideY = p.y >= cubeMin.y && p.y <= cubeMax.y;
    insideZ = p.z >= cubeMin.z && p.z <= cubeMax.z;
    return insideX && insideY && insideZ;
}

// The degree of the polynomials for which we compute roots
#if defined(USE_TRILINEAR_INTERPOLATION) && !defined(USE_TRICUBIC_IN_ISOSURFACE)
#define MAX_DEGREE 3
#endif
#if defined(USE_TRICUBIC_INTERPOLATION) || defined(USE_TRICUBIC_IN_ISOSURFACE)
#define MAX_DEGREE 9
#endif
// When there are fewer intersections/roots than theoretically possible, some
// array entries are set to this value
#define NO_INTERSECTION 3.4e38


#if defined(OCTREE_TRAVERSAL_AND_SOLVER) || defined(SPHERE_MARCHING_SOLVER) || defined(OCTREE_TRAVERSAL_AND_SH) || defined(SPHERE_MARCHING)


#if defined(USE_TRICUBIC_INTERPOLATION) || defined(USE_TRICUBIC_IN_ISOSURFACE)
// Searches a single root of a polynomial within a given interval.
// \param out_root The location of the found root.
// \param out_end_value The value of the given polynomial at end.
// \param poly Coefficients of the polynomial for which a root should be found.
//        Coefficient poly[i] is multiplied by x^i.
// \param begin The beginning of an interval where the polynomial is monotonic.
// \param end The end of said interval.
// \param begin_value The value of the given polynomial at begin.
// \param error_tolerance The error tolerance for the returned root location.
//        Typically the error will be much lower but in theory it can be
//        bigger.
// \return true if a root was found, false if no root exists.
bool newton_bisection(out float out_root, out float out_end_value,
    float poly[MAX_DEGREE + 1], float begin, float end,
    float begin_value, float error_tolerance)
{
    if (begin == end) {
        out_end_value = begin_value;
        return false;
    }
    // Evaluate the polynomial at the end of the interval
    out_end_value = poly[MAX_DEGREE];

    for (int i = MAX_DEGREE - 1; i != -1; --i)
        out_end_value = out_end_value * end + poly[i];
    // If the values at both ends have the same non-zero sign, there is no root
    if (begin_value * out_end_value > 0.0)
        return false;
    // Otherwise, we find the root iteratively using Newton bisection (with
    // bounded iteration count)
    float current = 0.5 * (begin + end);

    for (int i = 0; i != 90; ++i) {
        // Evaluate the polynomial and its derivative
        float value = poly[MAX_DEGREE] * current + poly[MAX_DEGREE - 1];
        float derivative = poly[MAX_DEGREE];

        for (int j = MAX_DEGREE - 2; j != -1; --j) {
            derivative = derivative * current + value;
            value = value * current + poly[j];
        }
        // Shorten the interval
        bool right = begin_value * value > 0.0;
        begin = right ? current : begin;
        end = right ? end : current;
        // Apply Newton's method
        float guess = current - value / derivative;
        // Pick a guess
        float middle = 0.5 * (begin + end);
        float next = (guess >= begin && guess <= end) ? guess : middle;
        // Move along or terminate
        bool done = abs(next - current) < error_tolerance;
        current = next;
        if (abs(value) * distanceScale < epsilon)
            break;
    }
    out_root = current;
    return true;
}


// Finds all roots of the given polynomial in the interval [begin, end] and
// writes them to out_roots. Some entries will be NO_INTERSECTION but other
// than that the array is sorted. The last entry is always NO_INTERSECTION.
void find_roots(out float out_roots[MAX_DEGREE + 1], float poly[MAX_DEGREE + 1], float begin, float end) {
    float tolerance = (end - begin) * epsilon;
    // Construct the quadratic derivative of the polynomial. We divide each
    // derivative by the factorial of its order, such that the constant
    // coefficient can be copied directly from poly. That is a safeguard
    // against overflow and makes it easier to avoid spilling below. The
    // factors happen to be binomial coefficients then.
    float derivative[MAX_DEGREE + 1];
    derivative[0] = poly[MAX_DEGREE - 2];
    derivative[1] = float(MAX_DEGREE - 1) * poly[MAX_DEGREE - 1];
    derivative[2] = (0.5 * float((MAX_DEGREE - 1) * MAX_DEGREE)) * poly[MAX_DEGREE - 0];

    for (int i = 3; i != MAX_DEGREE + 1; ++i)
        derivative[i] = 0.0;
    // Compute its two roots using the quadratic formula
    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];
    if (discriminant >= 0.0) {
        float sqrt_discriminant = sqrt(discriminant);
        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));
        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);
        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);
        out_roots[MAX_DEGREE - 2] = min(root_0, root_1);
        out_roots[MAX_DEGREE - 1] = max(root_0, root_1);
    }
    else {
        // Indicate that the cubic derivative has a single root
        out_roots[MAX_DEGREE - 2] = begin;
        out_roots[MAX_DEGREE - 1] = begin;
    }
    // The last entry in the root array is set to end to make it easier to
    // iterate over relevant intervals, all untouched roots are set to begin
    out_roots[MAX_DEGREE] = end;

    for (int i = 0; i != MAX_DEGREE - 2; ++i)
        out_roots[i] = begin;
    // Work your way up to derivatives of higher degree until you reach the
    // polynomial itself. This implementation may seem peculiar: It always
    // treats the derivative as though it had degree MAX_DEGREE and it
    // constructs the derivatives in a contrived way. Changing that would
    // reduce the number of arithmetic instructions roughly by a factor of two.
    // However, it would also cause register spilling, which has a far more
    // negative impact on the overall run time. Profiling indicates that the
    // current implementation has no spilling whatsoever.

    for (int degree = 3; degree != MAX_DEGREE + 1; ++degree) {
        // Take the integral of the previous derivative (scaled such that the
        // constant coefficient can still be copied directly from poly)
        float prev_derivative_order = float(MAX_DEGREE + 1 - degree);

        for (int i = MAX_DEGREE; i != 0; --i)
            derivative[i] = derivative[i - 1] * (prev_derivative_order * (1.0 / float(i)));
        // Copy the constant coefficient without causing spilling. This part
        // would be harder if the derivative were not scaled the way it is.

        for (int i = 0; i != MAX_DEGREE - 2; ++i)
            derivative[0] = (degree == MAX_DEGREE - i) ? poly[i] : derivative[0];
        // Determine the value of this derivative at begin
        float begin_value = derivative[MAX_DEGREE];

        for (int i = MAX_DEGREE - 1; i != -1; --i)
            begin_value = begin_value * begin + derivative[i];
        // Iterate over the intervals where roots may be found

        for (int i = 0; i != MAX_DEGREE; ++i) {
            if (i < MAX_DEGREE - degree)
                continue;
            float current_begin = out_roots[i];
            float current_end = out_roots[i + 1];
            // Try to find a root
            float root;
            if (newton_bisection(root, begin_value, derivative, current_begin, current_end, begin_value, tolerance))
                out_roots[i] = root;
            else if (degree < MAX_DEGREE)
                // Create an empty interval for the next iteration
                out_roots[i] = out_roots[i - 1];
            else
                out_roots[i] = NO_INTERSECTION;
        }
    }
    // We no longer need this array entry
    out_roots[MAX_DEGREE] = NO_INTERSECTION;
}
#endif

bool solvePolynomialEquation(vec3 o, vec3 dir, float tStart, uint leafNode, vec3 leafPos, float leafSize, out vec3 result, inout uint fIt)
{
    float t_res;
    vec3 p = (o - leafPos) / leafSize;
    vec3 v = dir / leafSize;

    float leaf_t_in, leaf_t_out;
    raySlabIntersection(vec3(0), vec3(1), p, 1/v, leaf_t_in, leaf_t_out);
    leaf_t_in = max(leaf_t_in, 0.0);

    float localEpsilon = epsilon * (tStart + 0.5 * leafSize);

#if defined(USE_TRILINEAR_INTERPOLATION) && !defined(USE_TRICUBIC_IN_ISOSURFACE)
    uint vIndex = leafNode & childrenIndexMask;

    // float[8] values;
    // vec4 v1 = octreeValues[vIndex];
    // vec4 v2 = octreeValues[vIndex+1];

    // values[0] = v1.x; // S000
    // values[1] = v1.y - values[0]; // S100 - S000
    // values[2] = v1.z; // S010
    // values[3] = v1.w - values[2] - values[1]; //S110 - S010 - values[1]
    // values[2] = values[2] - values[0]; // S010 - S000
    // values[4] = v2.x; // S001
    // values[5] = v2.y - values[4]; // S101 - S001 (a)
    // values[6] = v2.z; // S011
    // values[7] = values[3] - v2.w + values[6] + values[5];
    // values[6] = values[2] - values[6] + values[4];
    // values[5] = values[1] - values[5];
    // values[4] = values[0] - values[4];

    // float[6] m;
    // m[0] = p.x*p.y;
    // m[1] = v.x*v.y;
    // m[2] = p.x*v.y + p.y*v.x;
    // m[3] = values[5]*p.z - values[1];
    // m[4] = values[6]*p.z - values[2];
    // m[5] = values[7]*p.z - values[3];

    // float[4] eq;
    // eq[0] = -(values[4]*p.z - values[0] + p.x * m[3] + p.y * m[4] + m[0] * m[5]);
    // eq[1] = -(v.x * m[3] + v.y * m[4] + m[2] * m[5] + v.z * (values[4] + values[5] * p.x + values[6] * p.y + values[7] * m[0]));
    // eq[2] = -(m[1] * m[5] + v.z * (values[5] * v.x + values[6] * v.y + values[7] * m[2]));
    // eq[3] = -values[7] * m[1] * v.z;


    vec4 v1 = octreeValues[vIndex];
    vec4 v2 = octreeValues[vIndex+1];

    // float[4] eq;
    // eq[0] = p.x*p.y*p.z*v2.w + p.x*p.y*v2.y + p.x*p.z*v2.z + p.x*v2.x + p.y*p.z*v1.w + p.y*v1.y + p.z*v1.z + v1.x;
    // eq[1] = p.x*p.y*v.z*v2.w + p.x*p.z*v.y*v2.w + p.x*v.y*v2.y + p.x*v.z*v2.z + p.y*p.z*v.x*v2.w + p.y*v.x*v2.y + p.y*v.z*v1.w + p.z*v.x*v2.z + p.z*v.y*v1.w + v.x*v2.x + v.y*v1.y + v.z*v1.z;
    // eq[2] = p.x*v.y*v.z*v2.w + p.y*v.x*v.z*v2.w + p.z*v.x*v.y*v2.w + v.x*v.y*v2.y + v.x*v.z*v2.z + v.y*v.z*v1.w;
    // eq[3] = v.x*v.y*v.z*v2.w;

    float[4] eq;
    vec4 pl = vec4(1.0, p.y, p.z, p.y * p.z);
    vec4 xl = vec4(v.y, v.z, v.y, v.z);
    eq[0] = dot(v2, pl); // Mul all x
    vec4 aux = v2.yzww * xl;
    eq[1] = dot(aux, pl.xxzy);
    eq[3] = v.y * aux.w;
    eq[2] = v.x * eq[1] + p.x * eq[3] + v1.w * v.y * v.z;
    eq[3] = v.x * eq[3];
    eq[1] = v.x * eq[0] + p.x * eq[1] + dot(v1.yzww * xl, pl.xxzy);
    eq[0] = p.x * eq[0] + dot(v1, pl);

#if defined(OCTREE_TRAVERSAL_AND_SOLVER) || defined(SPHERE_MARCHING_SOLVER)
    // Unroll method
    // float derivative[3];
    // derivative[0] = eq[1];
    // derivative[1] = 2.0 * eq[2];
    // derivative[2] = 3.0 * eq[3];

    // float begin = leaf_t_in;
    // float end = leaf_t_out;

    vec2 val = vec2(leaf_t_in, leaf_t_out);
    val = ((eq[3] * val + eq[2]) * val + eq[1]) * val + eq[0];

    // if(leaf_t_in + distanceScale * max(val.x, 0) > leaf_t_out - distanceScale * max(val.y, 0)) return false;
    if(leaf_t_in + distanceScale * val.x > leaf_t_out) return false;

    // Compute its two roots using the quadratic formula
    // float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];
    fIt = 1;
    float discriminant = 4.0 * eq[2] * eq[2] - 12.0 * eq[1] * eq[3];
    if (discriminant >= 0.0) {
        discriminant = sqrt(discriminant);
        discriminant = 2.0 * eq[2] + ((eq[2] > 0.0) ? discriminant : (-discriminant));
        float r0 = clamp(-2.0 * eq[1] / discriminant, leaf_t_in, leaf_t_out);
        float r1 = clamp(-0.166666666666666666666 * discriminant / eq[3], leaf_t_in, leaf_t_out);

        float root_0 = min(r0, r1);
        float root_1 = max(r0, r1);

        vec2 tval = vec2(root_0, root_1);
        tval = ((eq[3]*tval + eq[2])*tval + eq[1]) * tval + eq[0];

        if(val.x * tval.x <= 0.0) 
        {
            leaf_t_out = root_0; val.y = tval.x;
        }
        else if(tval.x * tval.y <= 0.0)
        {
            leaf_t_in = root_0; leaf_t_out = root_1; val = tval;
        }
        else if(tval.y * val.y <= 0.0)
        {
            leaf_t_in = root_1; val.x = tval.y;
        }
        else return false;
    }
    else if(val.x * val.y > 0.0) return false;

    // float t = 0.5 * (begin + end);
    // result = o + dir * 0.5 * (leaf_t_in + leaf_t_out);
    // return true;

    float begin = leaf_t_in;
    float end = leaf_t_out;
    float t = 0.5 * (leaf_t_in + leaf_t_out);

    // vec2 value = vec2(eq[3] * t + eq[2], eq[3]);

    // value = value * t + vec2(eq[1], value.x);

    // value = value * t + vec2(eq[0], value.x);

    // // Shorten the interval
    // bool right = val.x * value.x > 0.0;
    // leaf_t_in = right ? t : leaf_t_in;
    // leaf_t_out = right ? leaf_t_out : t;

    // // Apply Newton's method
    // float guess = t - value.x / value.y;
    // // Pick a guess
    // float middle = 0.5 * (leaf_t_in + leaf_t_out);
    // t = (guess >= leaf_t_in && guess <= leaf_t_out) ? guess : middle;
    // Move along or terminate
    // t = next;

    fIt = 10;
    // float t = begin;
    for (int i = 0; i != 80; ++i) {
        // Evaluate the polynomial and its derivative
        vec2 value = vec2(eq[3] * t + eq[2], eq[3]);

        float aux = value.x;
        value = value * t + vec2(eq[1], aux);

        aux = value.x;
        value = value * t + vec2(eq[0], aux);

        // Shorten the interval
        bool right = val.x * value.x > 0.0;
        begin = right ? t : begin;
        end = right ? end : t;

        // Apply Newton's method
        float guess = t - value.x / value.y;
        // Pick a guess
        float middle = 0.5 * (begin + end);
        float next = (guess >= begin && guess <= end) ? guess : middle;
        // Move along or terminate
        t = next;
        fIt++;   

        if (distanceScale * abs(value.x) < epsilon)
            break;
    }
    
    result = o + dir * t;
    return true;
#endif

#if defined(SPHERE_MARCHING) || defined(OCTREE_TRAVERSAL_AND_SH)
    float lastDistance = 1e8;
    uint it = 0;
    float t=leaf_t_in;
    while (lastDistance > localEpsilon && t < leaf_t_out && it < 1280)
    {   
        lastDistance = distanceScale * evalNode(vIndex, p + v * t);
        // vec4 d = v1 + (p.x + v.x * t) * v2;
        // vec2 f = d.xz + (p.y + v.y * t) * d.yw;
        // lastDistance = distanceScale * (f.x +  (p.z + v.z * t) * f.y);
        // lastDistance = distanceScale * (((eq[3] * t + eq[2]) * t + eq[1]) * t + eq[0]);
        float dist = max(lastDistance, 0.0);
        t += dist;
        it += 1;
    }

    fIt += it;

    result = o + dir * t;
    return lastDistance < localEpsilon;
#endif

    // values[0] = uintBitsToFloat(octreeData[vIndex]); // S000
    // values[1] = uintBitsToFloat(octreeData[vIndex + 1]); // S100 - S000
    // values[2] = uintBitsToFloat(octreeData[vIndex + 2]); // S010
    // values[3] = uintBitsToFloat(octreeData[vIndex + 3]); //S110 - S010 - values[1]
    // values[4] = uintBitsToFloat(octreeData[vIndex + 4]); // S001
    // values[5] = uintBitsToFloat(octreeData[vIndex + 5]); // S101 - S001 (a)
    // values[6] = uintBitsToFloat(octreeData[vIndex + 6]); // S011
    // values[7] = uintBitsToFloat(octreeData[vIndex + 7]);

    // eq[0] = -p.x*p.y*p.z*values[0] + p.x*p.y*p.z*values[1] + p.x*p.y*p.z*values[2] - p.x*p.y*p.z*values[3] + p.x*p.y*p.z*values[4] - p.x*p.y*p.z*values[5] - p.x*p.y*p.z*values[6] + p.x*p.y*p.z*values[7] + 1.0*p.x*p.y*values[0] - 1.0*p.x*p.y*values[1] - 1.0*p.x*p.y*values[2] + 1.0*p.x*p.y*values[3] + 1.0*p.x*p.z*values[0] - 1.0*p.x*p.z*values[1] - 1.0*p.x*p.z*values[4] + 1.0*p.x*p.z*values[5] - 1.0*p.x*values[0] + 1.0*p.x*values[1] + 1.0*p.y*p.z*values[0] - 1.0*p.y*p.z*values[2] - 1.0*p.y*p.z*values[4] + 1.0*p.y*p.z*values[6] - 1.0*p.y*values[0] + 1.0*p.y*values[2] - 1.0*p.z*values[0] + 1.0*p.z*values[4] + 1.0*values[0];
    // eq[1] = -p.x*p.y*v.z*values[0] + p.x*p.y*v.z*values[1] + p.x*p.y*v.z*values[2] - p.x*p.y*v.z*values[3] + p.x*p.y*v.z*values[4] - p.x*p.y*v.z*values[5] - p.x*p.y*v.z*values[6] + p.x*p.y*v.z*values[7] - p.x*p.z*v.y*values[0] + p.x*p.z*v.y*values[1] + p.x*p.z*v.y*values[2] - p.x*p.z*v.y*values[3] + p.x*p.z*v.y*values[4] - p.x*p.z*v.y*values[5] - p.x*p.z*v.y*values[6] + p.x*p.z*v.y*values[7] + 1.0*p.x*v.y*values[0] - 1.0*p.x*v.y*values[1] - 1.0*p.x*v.y*values[2] + 1.0*p.x*v.y*values[3] + 1.0*p.x*v.z*values[0] - 1.0*p.x*v.z*values[1] - 1.0*p.x*v.z*values[4] + 1.0*p.x*v.z*values[5] - p.y*p.z*v.x*values[0] + p.y*p.z*v.x*values[1] + p.y*p.z*v.x*values[2] - p.y*p.z*v.x*values[3] + p.y*p.z*v.x*values[4] - p.y*p.z*v.x*values[5] - p.y*p.z*v.x*values[6] + p.y*p.z*v.x*values[7] + 1.0*p.y*v.x*values[0] - 1.0*p.y*v.x*values[1] - 1.0*p.y*v.x*values[2] + 1.0*p.y*v.x*values[3] + 1.0*p.y*v.z*values[0] - 1.0*p.y*v.z*values[2] - 1.0*p.y*v.z*values[4] + 1.0*p.y*v.z*values[6] + 1.0*p.z*v.x*values[0] - 1.0*p.z*v.x*values[1] - 1.0*p.z*v.x*values[4] + 1.0*p.z*v.x*values[5] + 1.0*p.z*v.y*values[0] - 1.0*p.z*v.y*values[2] - 1.0*p.z*v.y*values[4] + 1.0*p.z*v.y*values[6] - 1.0*v.x*values[0] + 1.0*v.x*values[1] - 1.0*v.y*values[0] + 1.0*v.y*values[2] - 1.0*v.z*values[0] + 1.0*v.z*values[4];
    // eq[2] = -p.x*v.y*v.z*values[0] + p.x*v.y*v.z*values[1] + p.x*v.y*v.z*values[2] - p.x*v.y*v.z*values[3] + p.x*v.y*v.z*values[4] - p.x*v.y*v.z*values[5] - p.x*v.y*v.z*values[6] + p.x*v.y*v.z*values[7] - p.y*v.x*v.z*values[0] + p.y*v.x*v.z*values[1] + p.y*v.x*v.z*values[2] - p.y*v.x*v.z*values[3] + p.y*v.x*v.z*values[4] - p.y*v.x*v.z*values[5] - p.y*v.x*v.z*values[6] + p.y*v.x*v.z*values[7] - p.z*v.x*v.y*values[0] + p.z*v.x*v.y*values[1] + p.z*v.x*v.y*values[2] - p.z*v.x*v.y*values[3] + p.z*v.x*v.y*values[4] - p.z*v.x*v.y*values[5] - p.z*v.x*v.y*values[6] + p.z*v.x*v.y*values[7] + 1.0*v.x*v.y*values[0] - 1.0*v.x*v.y*values[1] - 1.0*v.x*v.y*values[2] + 1.0*v.x*v.y*values[3] + 1.0*v.x*v.z*values[0] - 1.0*v.x*v.z*values[1] - 1.0*v.x*v.z*values[4] + 1.0*v.x*v.z*values[5] + 1.0*v.y*v.z*values[0] - 1.0*v.y*v.z*values[2] - 1.0*v.y*v.z*values[4] + 1.0*v.y*v.z*values[6];
    // eq[3] = -v.x*v.y*v.z*values[0] + v.x*v.y*v.z*values[1] + v.x*v.y*v.z*values[2] - v.x*v.y*v.z*values[3] + v.x*v.y*v.z*values[4] - v.x*v.y*v.z*values[5] - v.x*v.y*v.z*values[6] + v.x*v.y*v.z*values[7];
    
#endif
#if defined(USE_TRICUBIC_INTERPOLATION) || defined(USE_TRICUBIC_IN_ISOSURFACE)
    // Normalize values
    p = p + v * leaf_t_in;
    leaf_t_out -= leaf_t_in; leaf_t_in = 0.0;
    float sfactor = leaf_t_out; v = leaf_t_out * v;
    leaf_t_out = 1.0;

    uint vIndex = leafNode & childrenIndexMask;

    // float[64] values;
    // for(int i=0; i < 64; i++)
    // {
    //     values[i] = octreeValues[vIndex + i/4][i%4];
    // }

    // float[10] eq;

    // vec3 pow2p = p * p;
    // vec3 pow3p = pow2p * p;

    // vec3 pow2v = v * v;
    // vec3 pow3v = pow2v * v;

    // eq[0] = pow3p.x*pow3p.y*pow3p.z*values[63] + pow3p.x*pow3p.y*pow2p.z*values[47] + pow3p.x*pow3p.y*p.z*values[31] + pow3p.x*pow3p.y*values[15] + pow3p.x*pow2p.y*pow3p.z*values[59] + pow3p.x*pow2p.y*pow2p.z*values[43] + pow3p.x*pow2p.y*p.z*values[27] + pow3p.x*pow2p.y*values[11] + pow3p.x*p.y*pow3p.z*values[55] + pow3p.x*p.y*pow2p.z*values[39] + pow3p.x*p.y*p.z*values[23] + pow3p.x*p.y*values[7] + pow3p.x*pow3p.z*values[51] + pow3p.x*pow2p.z*values[35] + pow3p.x*p.z*values[19] + pow3p.x*values[3] + pow2p.x*pow3p.y*pow3p.z*values[62] + pow2p.x*pow3p.y*pow2p.z*values[46] + pow2p.x*pow3p.y*p.z*values[30] + pow2p.x*pow3p.y*values[14] + pow2p.x*pow2p.y*pow3p.z*values[58] + pow2p.x*pow2p.y*pow2p.z*values[42] + pow2p.x*pow2p.y*p.z*values[26] + pow2p.x*pow2p.y*values[10] + pow2p.x*p.y*pow3p.z*values[54] + pow2p.x*p.y*pow2p.z*values[38] + pow2p.x*p.y*p.z*values[22] + pow2p.x*p.y*values[6] + pow2p.x*pow3p.z*values[50] + pow2p.x*pow2p.z*values[34] + pow2p.x*p.z*values[18] + pow2p.x*values[2] + p.x*pow3p.y*pow3p.z*values[61] + p.x*pow3p.y*pow2p.z*values[45] + p.x*pow3p.y*p.z*values[29] + p.x*pow3p.y*values[13] + p.x*pow2p.y*pow3p.z*values[57] + p.x*pow2p.y*pow2p.z*values[41] + p.x*pow2p.y*p.z*values[25] + p.x*pow2p.y*values[9] + p.x*p.y*pow3p.z*values[53] + p.x*p.y*pow2p.z*values[37] + p.x*p.y*p.z*values[21] + p.x*p.y*values[5] + p.x*pow3p.z*values[49] + p.x*pow2p.z*values[33] + p.x*p.z*values[17] + p.x*values[1] + pow3p.y*pow3p.z*values[60] + pow3p.y*pow2p.z*values[44] + pow3p.y*p.z*values[28] + pow3p.y*values[12] + pow2p.y*pow3p.z*values[56] + pow2p.y*pow2p.z*values[40] + pow2p.y*p.z*values[24] + pow2p.y*values[8] + p.y*pow3p.z*values[52] + p.y*pow2p.z*values[36] + p.y*p.z*values[20] + p.y*values[4] + pow3p.z*values[48] + pow2p.z*values[32] + p.z*values[16] + values[0];
    // eq[1] = 3*pow3p.x*pow3p.y*pow2p.z*v.z*values[63] + 2*pow3p.x*pow3p.y*p.z*v.z*values[47] + pow3p.x*pow3p.y*v.z*values[31] + 3*pow3p.x*pow2p.y*pow3p.z*v.y*values[63] + 3*pow3p.x*pow2p.y*pow2p.z*v.y*values[47] + 3*pow3p.x*pow2p.y*pow2p.z*v.z*values[59] + 3*pow3p.x*pow2p.y*p.z*v.y*values[31] + 2*pow3p.x*pow2p.y*p.z*v.z*values[43] + 3*pow3p.x*pow2p.y*v.y*values[15] + pow3p.x*pow2p.y*v.z*values[27] + 2*pow3p.x*p.y*pow3p.z*v.y*values[59] + 2*pow3p.x*p.y*pow2p.z*v.y*values[43] + 3*pow3p.x*p.y*pow2p.z*v.z*values[55] + 2*pow3p.x*p.y*p.z*v.y*values[27] + 2*pow3p.x*p.y*p.z*v.z*values[39] + 2*pow3p.x*p.y*v.y*values[11] + pow3p.x*p.y*v.z*values[23] + pow3p.x*pow3p.z*v.y*values[55] + pow3p.x*pow2p.z*v.y*values[39] + 3*pow3p.x*pow2p.z*v.z*values[51] + pow3p.x*p.z*v.y*values[23] + 2*pow3p.x*p.z*v.z*values[35] + pow3p.x*v.y*values[7] + pow3p.x*v.z*values[19] + 3*pow2p.x*pow3p.y*pow3p.z*v.x*values[63] + 3*pow2p.x*pow3p.y*pow2p.z*v.x*values[47] + 3*pow2p.x*pow3p.y*pow2p.z*v.z*values[62] + 3*pow2p.x*pow3p.y*p.z*v.x*values[31] + 2*pow2p.x*pow3p.y*p.z*v.z*values[46] + 3*pow2p.x*pow3p.y*v.x*values[15] + pow2p.x*pow3p.y*v.z*values[30] + 3*pow2p.x*pow2p.y*pow3p.z*v.x*values[59] + 3*pow2p.x*pow2p.y*pow3p.z*v.y*values[62] + 3*pow2p.x*pow2p.y*pow2p.z*v.x*values[43] + 3*pow2p.x*pow2p.y*pow2p.z*v.y*values[46] + 3*pow2p.x*pow2p.y*pow2p.z*v.z*values[58] + 3*pow2p.x*pow2p.y*p.z*v.x*values[27] + 3*pow2p.x*pow2p.y*p.z*v.y*values[30] + 2*pow2p.x*pow2p.y*p.z*v.z*values[42] + 3*pow2p.x*pow2p.y*v.x*values[11] + 3*pow2p.x*pow2p.y*v.y*values[14] + pow2p.x*pow2p.y*v.z*values[26] + 3*pow2p.x*p.y*pow3p.z*v.x*values[55] + 2*pow2p.x*p.y*pow3p.z*v.y*values[58] + 3*pow2p.x*p.y*pow2p.z*v.x*values[39] + 2*pow2p.x*p.y*pow2p.z*v.y*values[42] + 3*pow2p.x*p.y*pow2p.z*v.z*values[54] + 3*pow2p.x*p.y*p.z*v.x*values[23] + 2*pow2p.x*p.y*p.z*v.y*values[26] + 2*pow2p.x*p.y*p.z*v.z*values[38] + 3*pow2p.x*p.y*v.x*values[7] + 2*pow2p.x*p.y*v.y*values[10] + pow2p.x*p.y*v.z*values[22] + 3*pow2p.x*pow3p.z*v.x*values[51] + pow2p.x*pow3p.z*v.y*values[54] + 3*pow2p.x*pow2p.z*v.x*values[35] + pow2p.x*pow2p.z*v.y*values[38] + 3*pow2p.x*pow2p.z*v.z*values[50] + 3*pow2p.x*p.z*v.x*values[19] + pow2p.x*p.z*v.y*values[22] + 2*pow2p.x*p.z*v.z*values[34] + 3*pow2p.x*v.x*values[3] + pow2p.x*v.y*values[6] + pow2p.x*v.z*values[18] + 2*p.x*pow3p.y*pow3p.z*v.x*values[62] + 2*p.x*pow3p.y*pow2p.z*v.x*values[46] + 3*p.x*pow3p.y*pow2p.z*v.z*values[61] + 2*p.x*pow3p.y*p.z*v.x*values[30] + 2*p.x*pow3p.y*p.z*v.z*values[45] + 2*p.x*pow3p.y*v.x*values[14] + p.x*pow3p.y*v.z*values[29] + 2*p.x*pow2p.y*pow3p.z*v.x*values[58] + 3*p.x*pow2p.y*pow3p.z*v.y*values[61] + 2*p.x*pow2p.y*pow2p.z*v.x*values[42] + 3*p.x*pow2p.y*pow2p.z*v.y*values[45] + 3*p.x*pow2p.y*pow2p.z*v.z*values[57] + 2*p.x*pow2p.y*p.z*v.x*values[26] + 3*p.x*pow2p.y*p.z*v.y*values[29] + 2*p.x*pow2p.y*p.z*v.z*values[41] + 2*p.x*pow2p.y*v.x*values[10] + 3*p.x*pow2p.y*v.y*values[13] + p.x*pow2p.y*v.z*values[25] + 2*p.x*p.y*pow3p.z*v.x*values[54] + 2*p.x*p.y*pow3p.z*v.y*values[57] + 2*p.x*p.y*pow2p.z*v.x*values[38] + 2*p.x*p.y*pow2p.z*v.y*values[41] + 3*p.x*p.y*pow2p.z*v.z*values[53] + 2*p.x*p.y*p.z*v.x*values[22] + 2*p.x*p.y*p.z*v.y*values[25] + 2*p.x*p.y*p.z*v.z*values[37] + 2*p.x*p.y*v.x*values[6] + 2*p.x*p.y*v.y*values[9] + p.x*p.y*v.z*values[21] + 2*p.x*pow3p.z*v.x*values[50] + p.x*pow3p.z*v.y*values[53] + 2*p.x*pow2p.z*v.x*values[34] + p.x*pow2p.z*v.y*values[37] + 3*p.x*pow2p.z*v.z*values[49] + 2*p.x*p.z*v.x*values[18] + p.x*p.z*v.y*values[21] + 2*p.x*p.z*v.z*values[33] + 2*p.x*v.x*values[2] + p.x*v.y*values[5] + p.x*v.z*values[17] + pow3p.y*pow3p.z*v.x*values[61] + pow3p.y*pow2p.z*v.x*values[45] + 3*pow3p.y*pow2p.z*v.z*values[60] + pow3p.y*p.z*v.x*values[29] + 2*pow3p.y*p.z*v.z*values[44] + pow3p.y*v.x*values[13] + pow3p.y*v.z*values[28] + pow2p.y*pow3p.z*v.x*values[57] + 3*pow2p.y*pow3p.z*v.y*values[60] + pow2p.y*pow2p.z*v.x*values[41] + 3*pow2p.y*pow2p.z*v.y*values[44] + 3*pow2p.y*pow2p.z*v.z*values[56] + pow2p.y*p.z*v.x*values[25] + 3*pow2p.y*p.z*v.y*values[28] + 2*pow2p.y*p.z*v.z*values[40] + pow2p.y*v.x*values[9] + 3*pow2p.y*v.y*values[12] + pow2p.y*v.z*values[24] + p.y*pow3p.z*v.x*values[53] + 2*p.y*pow3p.z*v.y*values[56] + p.y*pow2p.z*v.x*values[37] + 2*p.y*pow2p.z*v.y*values[40] + 3*p.y*pow2p.z*v.z*values[52] + p.y*p.z*v.x*values[21] + 2*p.y*p.z*v.y*values[24] + 2*p.y*p.z*v.z*values[36] + p.y*v.x*values[5] + 2*p.y*v.y*values[8] + p.y*v.z*values[20] + pow3p.z*v.x*values[49] + pow3p.z*v.y*values[52] + pow2p.z*v.x*values[33] + pow2p.z*v.y*values[36] + 3*pow2p.z*v.z*values[48] + p.z*v.x*values[17] + p.z*v.y*values[20] + 2*p.z*v.z*values[32] + v.x*values[1] + v.y*values[4] + v.z*values[16];
    // eq[2] = 3*pow3p.x*pow3p.y*p.z*pow2v.z*values[63] + pow3p.x*pow3p.y*pow2v.z*values[47] + 9*pow3p.x*pow2p.y*pow2p.z*v.y*v.z*values[63] + 6*pow3p.x*pow2p.y*p.z*v.y*v.z*values[47] + 3*pow3p.x*pow2p.y*p.z*pow2v.z*values[59] + 3*pow3p.x*pow2p.y*v.y*v.z*values[31] + pow3p.x*pow2p.y*pow2v.z*values[43] + 3*pow3p.x*p.y*pow3p.z*pow2v.y*values[63] + 3*pow3p.x*p.y*pow2p.z*pow2v.y*values[47] + 6*pow3p.x*p.y*pow2p.z*v.y*v.z*values[59] + 3*pow3p.x*p.y*p.z*pow2v.y*values[31] + 4*pow3p.x*p.y*p.z*v.y*v.z*values[43] + 3*pow3p.x*p.y*p.z*pow2v.z*values[55] + 3*pow3p.x*p.y*pow2v.y*values[15] + 2*pow3p.x*p.y*v.y*v.z*values[27] + pow3p.x*p.y*pow2v.z*values[39] + pow3p.x*pow3p.z*pow2v.y*values[59] + pow3p.x*pow2p.z*pow2v.y*values[43] + 3*pow3p.x*pow2p.z*v.y*v.z*values[55] + pow3p.x*p.z*pow2v.y*values[27] + 2*pow3p.x*p.z*v.y*v.z*values[39] + 3*pow3p.x*p.z*pow2v.z*values[51] + pow3p.x*pow2v.y*values[11] + pow3p.x*v.y*v.z*values[23] + pow3p.x*pow2v.z*values[35] + 9*pow2p.x*pow3p.y*pow2p.z*v.x*v.z*values[63] + 6*pow2p.x*pow3p.y*p.z*v.x*v.z*values[47] + 3*pow2p.x*pow3p.y*p.z*pow2v.z*values[62] + 3*pow2p.x*pow3p.y*v.x*v.z*values[31] + pow2p.x*pow3p.y*pow2v.z*values[46] + 9*pow2p.x*pow2p.y*pow3p.z*v.x*v.y*values[63] + 9*pow2p.x*pow2p.y*pow2p.z*v.x*v.y*values[47] + 9*pow2p.x*pow2p.y*pow2p.z*v.x*v.z*values[59] + 9*pow2p.x*pow2p.y*pow2p.z*v.y*v.z*values[62] + 9*pow2p.x*pow2p.y*p.z*v.x*v.y*values[31] + 6*pow2p.x*pow2p.y*p.z*v.x*v.z*values[43] + 6*pow2p.x*pow2p.y*p.z*v.y*v.z*values[46] + 3*pow2p.x*pow2p.y*p.z*pow2v.z*values[58] + 9*pow2p.x*pow2p.y*v.x*v.y*values[15] + 3*pow2p.x*pow2p.y*v.x*v.z*values[27] + 3*pow2p.x*pow2p.y*v.y*v.z*values[30] + pow2p.x*pow2p.y*pow2v.z*values[42] + 6*pow2p.x*p.y*pow3p.z*v.x*v.y*values[59] + 3*pow2p.x*p.y*pow3p.z*pow2v.y*values[62] + 6*pow2p.x*p.y*pow2p.z*v.x*v.y*values[43] + 9*pow2p.x*p.y*pow2p.z*v.x*v.z*values[55] + 3*pow2p.x*p.y*pow2p.z*pow2v.y*values[46] + 6*pow2p.x*p.y*pow2p.z*v.y*v.z*values[58] + 6*pow2p.x*p.y*p.z*v.x*v.y*values[27] + 6*pow2p.x*p.y*p.z*v.x*v.z*values[39] + 3*pow2p.x*p.y*p.z*pow2v.y*values[30] + 4*pow2p.x*p.y*p.z*v.y*v.z*values[42] + 3*pow2p.x*p.y*p.z*pow2v.z*values[54] + 6*pow2p.x*p.y*v.x*v.y*values[11] + 3*pow2p.x*p.y*v.x*v.z*values[23] + 3*pow2p.x*p.y*pow2v.y*values[14] + 2*pow2p.x*p.y*v.y*v.z*values[26] + pow2p.x*p.y*pow2v.z*values[38] + 3*pow2p.x*pow3p.z*v.x*v.y*values[55] + pow2p.x*pow3p.z*pow2v.y*values[58] + 3*pow2p.x*pow2p.z*v.x*v.y*values[39] + 9*pow2p.x*pow2p.z*v.x*v.z*values[51] + pow2p.x*pow2p.z*pow2v.y*values[42] + 3*pow2p.x*pow2p.z*v.y*v.z*values[54] + 3*pow2p.x*p.z*v.x*v.y*values[23] + 6*pow2p.x*p.z*v.x*v.z*values[35] + pow2p.x*p.z*pow2v.y*values[26] + 2*pow2p.x*p.z*v.y*v.z*values[38] + 3*pow2p.x*p.z*pow2v.z*values[50] + 3*pow2p.x*v.x*v.y*values[7] + 3*pow2p.x*v.x*v.z*values[19] + pow2p.x*pow2v.y*values[10] + pow2p.x*v.y*v.z*values[22] + pow2p.x*pow2v.z*values[34] + 3*p.x*pow3p.y*pow3p.z*pow2v.x*values[63] + 3*p.x*pow3p.y*pow2p.z*pow2v.x*values[47] + 6*p.x*pow3p.y*pow2p.z*v.x*v.z*values[62] + 3*p.x*pow3p.y*p.z*pow2v.x*values[31] + 4*p.x*pow3p.y*p.z*v.x*v.z*values[46] + 3*p.x*pow3p.y*p.z*pow2v.z*values[61] + 3*p.x*pow3p.y*pow2v.x*values[15] + 2*p.x*pow3p.y*v.x*v.z*values[30] + p.x*pow3p.y*pow2v.z*values[45] + 3*p.x*pow2p.y*pow3p.z*pow2v.x*values[59] + 6*p.x*pow2p.y*pow3p.z*v.x*v.y*values[62] + 3*p.x*pow2p.y*pow2p.z*pow2v.x*values[43] + 6*p.x*pow2p.y*pow2p.z*v.x*v.y*values[46] + 6*p.x*pow2p.y*pow2p.z*v.x*v.z*values[58] + 9*p.x*pow2p.y*pow2p.z*v.y*v.z*values[61] + 3*p.x*pow2p.y*p.z*pow2v.x*values[27] + 6*p.x*pow2p.y*p.z*v.x*v.y*values[30] + 4*p.x*pow2p.y*p.z*v.x*v.z*values[42] + 6*p.x*pow2p.y*p.z*v.y*v.z*values[45] + 3*p.x*pow2p.y*p.z*pow2v.z*values[57] + 3*p.x*pow2p.y*pow2v.x*values[11] + 6*p.x*pow2p.y*v.x*v.y*values[14] + 2*p.x*pow2p.y*v.x*v.z*values[26] + 3*p.x*pow2p.y*v.y*v.z*values[29] + p.x*pow2p.y*pow2v.z*values[41] + 3*p.x*p.y*pow3p.z*pow2v.x*values[55] + 4*p.x*p.y*pow3p.z*v.x*v.y*values[58] + 3*p.x*p.y*pow3p.z*pow2v.y*values[61] + 3*p.x*p.y*pow2p.z*pow2v.x*values[39] + 4*p.x*p.y*pow2p.z*v.x*v.y*values[42] + 6*p.x*p.y*pow2p.z*v.x*v.z*values[54] + 3*p.x*p.y*pow2p.z*pow2v.y*values[45] + 6*p.x*p.y*pow2p.z*v.y*v.z*values[57] + 3*p.x*p.y*p.z*pow2v.x*values[23] + 4*p.x*p.y*p.z*v.x*v.y*values[26] + 4*p.x*p.y*p.z*v.x*v.z*values[38] + 3*p.x*p.y*p.z*pow2v.y*values[29] + 4*p.x*p.y*p.z*v.y*v.z*values[41] + 3*p.x*p.y*p.z*pow2v.z*values[53] + 3*p.x*p.y*pow2v.x*values[7] + 4*p.x*p.y*v.x*v.y*values[10] + 2*p.x*p.y*v.x*v.z*values[22] + 3*p.x*p.y*pow2v.y*values[13] + 2*p.x*p.y*v.y*v.z*values[25] + p.x*p.y*pow2v.z*values[37] + 3*p.x*pow3p.z*pow2v.x*values[51] + 2*p.x*pow3p.z*v.x*v.y*values[54] + p.x*pow3p.z*pow2v.y*values[57] + 3*p.x*pow2p.z*pow2v.x*values[35] + 2*p.x*pow2p.z*v.x*v.y*values[38] + 6*p.x*pow2p.z*v.x*v.z*values[50] + p.x*pow2p.z*pow2v.y*values[41] + 3*p.x*pow2p.z*v.y*v.z*values[53] + 3*p.x*p.z*pow2v.x*values[19] + 2*p.x*p.z*v.x*v.y*values[22] + 4*p.x*p.z*v.x*v.z*values[34] + p.x*p.z*pow2v.y*values[25] + 2*p.x*p.z*v.y*v.z*values[37] + 3*p.x*p.z*pow2v.z*values[49] + 3*p.x*pow2v.x*values[3] + 2*p.x*v.x*v.y*values[6] + 2*p.x*v.x*v.z*values[18] + p.x*pow2v.y*values[9] + p.x*v.y*v.z*values[21] + p.x*pow2v.z*values[33] + pow3p.y*pow3p.z*pow2v.x*values[62] + pow3p.y*pow2p.z*pow2v.x*values[46] + 3*pow3p.y*pow2p.z*v.x*v.z*values[61] + pow3p.y*p.z*pow2v.x*values[30] + 2*pow3p.y*p.z*v.x*v.z*values[45] + 3*pow3p.y*p.z*pow2v.z*values[60] + pow3p.y*pow2v.x*values[14] + pow3p.y*v.x*v.z*values[29] + pow3p.y*pow2v.z*values[44] + pow2p.y*pow3p.z*pow2v.x*values[58] + 3*pow2p.y*pow3p.z*v.x*v.y*values[61] + pow2p.y*pow2p.z*pow2v.x*values[42] + 3*pow2p.y*pow2p.z*v.x*v.y*values[45] + 3*pow2p.y*pow2p.z*v.x*v.z*values[57] + 9*pow2p.y*pow2p.z*v.y*v.z*values[60] + pow2p.y*p.z*pow2v.x*values[26] + 3*pow2p.y*p.z*v.x*v.y*values[29] + 2*pow2p.y*p.z*v.x*v.z*values[41] + 6*pow2p.y*p.z*v.y*v.z*values[44] + 3*pow2p.y*p.z*pow2v.z*values[56] + pow2p.y*pow2v.x*values[10] + 3*pow2p.y*v.x*v.y*values[13] + pow2p.y*v.x*v.z*values[25] + 3*pow2p.y*v.y*v.z*values[28] + pow2p.y*pow2v.z*values[40] + p.y*pow3p.z*pow2v.x*values[54] + 2*p.y*pow3p.z*v.x*v.y*values[57] + 3*p.y*pow3p.z*pow2v.y*values[60] + p.y*pow2p.z*pow2v.x*values[38] + 2*p.y*pow2p.z*v.x*v.y*values[41] + 3*p.y*pow2p.z*v.x*v.z*values[53] + 3*p.y*pow2p.z*pow2v.y*values[44] + 6*p.y*pow2p.z*v.y*v.z*values[56] + p.y*p.z*pow2v.x*values[22] + 2*p.y*p.z*v.x*v.y*values[25] + 2*p.y*p.z*v.x*v.z*values[37] + 3*p.y*p.z*pow2v.y*values[28] + 4*p.y*p.z*v.y*v.z*values[40] + 3*p.y*p.z*pow2v.z*values[52] + p.y*pow2v.x*values[6] + 2*p.y*v.x*v.y*values[9] + p.y*v.x*v.z*values[21] + 3*p.y*pow2v.y*values[12] + 2*p.y*v.y*v.z*values[24] + p.y*pow2v.z*values[36] + pow3p.z*pow2v.x*values[50] + pow3p.z*v.x*v.y*values[53] + pow3p.z*pow2v.y*values[56] + pow2p.z*pow2v.x*values[34] + pow2p.z*v.x*v.y*values[37] + 3*pow2p.z*v.x*v.z*values[49] + pow2p.z*pow2v.y*values[40] + 3*pow2p.z*v.y*v.z*values[52] + p.z*pow2v.x*values[18] + p.z*v.x*v.y*values[21] + 2*p.z*v.x*v.z*values[33] + p.z*pow2v.y*values[24] + 2*p.z*v.y*v.z*values[36] + 3*p.z*pow2v.z*values[48] + pow2v.x*values[2] + v.x*v.y*values[5] + v.x*v.z*values[17] + pow2v.y*values[8] + v.y*v.z*values[20] + pow2v.z*values[32];
    // eq[3] = pow3p.x*pow3p.y*pow3v.z*values[63] + 9*pow3p.x*pow2p.y*p.z*v.y*pow2v.z*values[63] + 3*pow3p.x*pow2p.y*v.y*pow2v.z*values[47] + pow3p.x*pow2p.y*pow3v.z*values[59] + 9*pow3p.x*p.y*pow2p.z*pow2v.y*v.z*values[63] + 6*pow3p.x*p.y*p.z*pow2v.y*v.z*values[47] + 6*pow3p.x*p.y*p.z*v.y*pow2v.z*values[59] + 3*pow3p.x*p.y*pow2v.y*v.z*values[31] + 2*pow3p.x*p.y*v.y*pow2v.z*values[43] + pow3p.x*p.y*pow3v.z*values[55] + pow3p.x*pow3p.z*pow3v.y*values[63] + pow3p.x*pow2p.z*pow3v.y*values[47] + 3*pow3p.x*pow2p.z*pow2v.y*v.z*values[59] + pow3p.x*p.z*pow3v.y*values[31] + 2*pow3p.x*p.z*pow2v.y*v.z*values[43] + 3*pow3p.x*p.z*v.y*pow2v.z*values[55] + pow3p.x*pow3v.y*values[15] + pow3p.x*pow2v.y*v.z*values[27] + pow3p.x*v.y*pow2v.z*values[39] + pow3p.x*pow3v.z*values[51] + 9*pow2p.x*pow3p.y*p.z*v.x*pow2v.z*values[63] + 3*pow2p.x*pow3p.y*v.x*pow2v.z*values[47] + pow2p.x*pow3p.y*pow3v.z*values[62] + 27*pow2p.x*pow2p.y*pow2p.z*v.x*v.y*v.z*values[63] + 18*pow2p.x*pow2p.y*p.z*v.x*v.y*v.z*values[47] + 9*pow2p.x*pow2p.y*p.z*v.x*pow2v.z*values[59] + 9*pow2p.x*pow2p.y*p.z*v.y*pow2v.z*values[62] + 9*pow2p.x*pow2p.y*v.x*v.y*v.z*values[31] + 3*pow2p.x*pow2p.y*v.x*pow2v.z*values[43] + 3*pow2p.x*pow2p.y*v.y*pow2v.z*values[46] + pow2p.x*pow2p.y*pow3v.z*values[58] + 9*pow2p.x*p.y*pow3p.z*v.x*pow2v.y*values[63] + 9*pow2p.x*p.y*pow2p.z*v.x*pow2v.y*values[47] + 18*pow2p.x*p.y*pow2p.z*v.x*v.y*v.z*values[59] + 9*pow2p.x*p.y*pow2p.z*pow2v.y*v.z*values[62] + 9*pow2p.x*p.y*p.z*v.x*pow2v.y*values[31] + 12*pow2p.x*p.y*p.z*v.x*v.y*v.z*values[43] + 9*pow2p.x*p.y*p.z*v.x*pow2v.z*values[55] + 6*pow2p.x*p.y*p.z*pow2v.y*v.z*values[46] + 6*pow2p.x*p.y*p.z*v.y*pow2v.z*values[58] + 9*pow2p.x*p.y*v.x*pow2v.y*values[15] + 6*pow2p.x*p.y*v.x*v.y*v.z*values[27] + 3*pow2p.x*p.y*v.x*pow2v.z*values[39] + 3*pow2p.x*p.y*pow2v.y*v.z*values[30] + 2*pow2p.x*p.y*v.y*pow2v.z*values[42] + pow2p.x*p.y*pow3v.z*values[54] + 3*pow2p.x*pow3p.z*v.x*pow2v.y*values[59] + pow2p.x*pow3p.z*pow3v.y*values[62] + 3*pow2p.x*pow2p.z*v.x*pow2v.y*values[43] + 9*pow2p.x*pow2p.z*v.x*v.y*v.z*values[55] + pow2p.x*pow2p.z*pow3v.y*values[46] + 3*pow2p.x*pow2p.z*pow2v.y*v.z*values[58] + 3*pow2p.x*p.z*v.x*pow2v.y*values[27] + 6*pow2p.x*p.z*v.x*v.y*v.z*values[39] + 9*pow2p.x*p.z*v.x*pow2v.z*values[51] + pow2p.x*p.z*pow3v.y*values[30] + 2*pow2p.x*p.z*pow2v.y*v.z*values[42] + 3*pow2p.x*p.z*v.y*pow2v.z*values[54] + 3*pow2p.x*v.x*pow2v.y*values[11] + 3*pow2p.x*v.x*v.y*v.z*values[23] + 3*pow2p.x*v.x*pow2v.z*values[35] + pow2p.x*pow3v.y*values[14] + pow2p.x*pow2v.y*v.z*values[26] + pow2p.x*v.y*pow2v.z*values[38] + pow2p.x*pow3v.z*values[50] + 9*p.x*pow3p.y*pow2p.z*pow2v.x*v.z*values[63] + 6*p.x*pow3p.y*p.z*pow2v.x*v.z*values[47] + 6*p.x*pow3p.y*p.z*v.x*pow2v.z*values[62] + 3*p.x*pow3p.y*pow2v.x*v.z*values[31] + 2*p.x*pow3p.y*v.x*pow2v.z*values[46] + p.x*pow3p.y*pow3v.z*values[61] + 9*p.x*pow2p.y*pow3p.z*pow2v.x*v.y*values[63] + 9*p.x*pow2p.y*pow2p.z*pow2v.x*v.y*values[47] + 9*p.x*pow2p.y*pow2p.z*pow2v.x*v.z*values[59] + 18*p.x*pow2p.y*pow2p.z*v.x*v.y*v.z*values[62] + 9*p.x*pow2p.y*p.z*pow2v.x*v.y*values[31] + 6*p.x*pow2p.y*p.z*pow2v.x*v.z*values[43] + 12*p.x*pow2p.y*p.z*v.x*v.y*v.z*values[46] + 6*p.x*pow2p.y*p.z*v.x*pow2v.z*values[58] + 9*p.x*pow2p.y*p.z*v.y*pow2v.z*values[61] + 9*p.x*pow2p.y*pow2v.x*v.y*values[15] + 3*p.x*pow2p.y*pow2v.x*v.z*values[27] + 6*p.x*pow2p.y*v.x*v.y*v.z*values[30] + 2*p.x*pow2p.y*v.x*pow2v.z*values[42] + 3*p.x*pow2p.y*v.y*pow2v.z*values[45] + p.x*pow2p.y*pow3v.z*values[57] + 6*p.x*p.y*pow3p.z*pow2v.x*v.y*values[59] + 6*p.x*p.y*pow3p.z*v.x*pow2v.y*values[62] + 6*p.x*p.y*pow2p.z*pow2v.x*v.y*values[43] + 9*p.x*p.y*pow2p.z*pow2v.x*v.z*values[55] + 6*p.x*p.y*pow2p.z*v.x*pow2v.y*values[46] + 12*p.x*p.y*pow2p.z*v.x*v.y*v.z*values[58] + 9*p.x*p.y*pow2p.z*pow2v.y*v.z*values[61] + 6*p.x*p.y*p.z*pow2v.x*v.y*values[27] + 6*p.x*p.y*p.z*pow2v.x*v.z*values[39] + 6*p.x*p.y*p.z*v.x*pow2v.y*values[30] + 8*p.x*p.y*p.z*v.x*v.y*v.z*values[42] + 6*p.x*p.y*p.z*v.x*pow2v.z*values[54] + 6*p.x*p.y*p.z*pow2v.y*v.z*values[45] + 6*p.x*p.y*p.z*v.y*pow2v.z*values[57] + 6*p.x*p.y*pow2v.x*v.y*values[11] + 3*p.x*p.y*pow2v.x*v.z*values[23] + 6*p.x*p.y*v.x*pow2v.y*values[14] + 4*p.x*p.y*v.x*v.y*v.z*values[26] + 2*p.x*p.y*v.x*pow2v.z*values[38] + 3*p.x*p.y*pow2v.y*v.z*values[29] + 2*p.x*p.y*v.y*pow2v.z*values[41] + p.x*p.y*pow3v.z*values[53] + 3*p.x*pow3p.z*pow2v.x*v.y*values[55] + 2*p.x*pow3p.z*v.x*pow2v.y*values[58] + p.x*pow3p.z*pow3v.y*values[61] + 3*p.x*pow2p.z*pow2v.x*v.y*values[39] + 9*p.x*pow2p.z*pow2v.x*v.z*values[51] + 2*p.x*pow2p.z*v.x*pow2v.y*values[42] + 6*p.x*pow2p.z*v.x*v.y*v.z*values[54] + p.x*pow2p.z*pow3v.y*values[45] + 3*p.x*pow2p.z*pow2v.y*v.z*values[57] + 3*p.x*p.z*pow2v.x*v.y*values[23] + 6*p.x*p.z*pow2v.x*v.z*values[35] + 2*p.x*p.z*v.x*pow2v.y*values[26] + 4*p.x*p.z*v.x*v.y*v.z*values[38] + 6*p.x*p.z*v.x*pow2v.z*values[50] + p.x*p.z*pow3v.y*values[29] + 2*p.x*p.z*pow2v.y*v.z*values[41] + 3*p.x*p.z*v.y*pow2v.z*values[53] + 3*p.x*pow2v.x*v.y*values[7] + 3*p.x*pow2v.x*v.z*values[19] + 2*p.x*v.x*pow2v.y*values[10] + 2*p.x*v.x*v.y*v.z*values[22] + 2*p.x*v.x*pow2v.z*values[34] + p.x*pow3v.y*values[13] + p.x*pow2v.y*v.z*values[25] + p.x*v.y*pow2v.z*values[37] + p.x*pow3v.z*values[49] + pow3p.y*pow3p.z*pow3v.x*values[63] + pow3p.y*pow2p.z*pow3v.x*values[47] + 3*pow3p.y*pow2p.z*pow2v.x*v.z*values[62] + pow3p.y*p.z*pow3v.x*values[31] + 2*pow3p.y*p.z*pow2v.x*v.z*values[46] + 3*pow3p.y*p.z*v.x*pow2v.z*values[61] + pow3p.y*pow3v.x*values[15] + pow3p.y*pow2v.x*v.z*values[30] + pow3p.y*v.x*pow2v.z*values[45] + pow3p.y*pow3v.z*values[60] + pow2p.y*pow3p.z*pow3v.x*values[59] + 3*pow2p.y*pow3p.z*pow2v.x*v.y*values[62] + pow2p.y*pow2p.z*pow3v.x*values[43] + 3*pow2p.y*pow2p.z*pow2v.x*v.y*values[46] + 3*pow2p.y*pow2p.z*pow2v.x*v.z*values[58] + 9*pow2p.y*pow2p.z*v.x*v.y*v.z*values[61] + pow2p.y*p.z*pow3v.x*values[27] + 3*pow2p.y*p.z*pow2v.x*v.y*values[30] + 2*pow2p.y*p.z*pow2v.x*v.z*values[42] + 6*pow2p.y*p.z*v.x*v.y*v.z*values[45] + 3*pow2p.y*p.z*v.x*pow2v.z*values[57] + 9*pow2p.y*p.z*v.y*pow2v.z*values[60] + pow2p.y*pow3v.x*values[11] + 3*pow2p.y*pow2v.x*v.y*values[14] + pow2p.y*pow2v.x*v.z*values[26] + 3*pow2p.y*v.x*v.y*v.z*values[29] + pow2p.y*v.x*pow2v.z*values[41] + 3*pow2p.y*v.y*pow2v.z*values[44] + pow2p.y*pow3v.z*values[56] + p.y*pow3p.z*pow3v.x*values[55] + 2*p.y*pow3p.z*pow2v.x*v.y*values[58] + 3*p.y*pow3p.z*v.x*pow2v.y*values[61] + p.y*pow2p.z*pow3v.x*values[39] + 2*p.y*pow2p.z*pow2v.x*v.y*values[42] + 3*p.y*pow2p.z*pow2v.x*v.z*values[54] + 3*p.y*pow2p.z*v.x*pow2v.y*values[45] + 6*p.y*pow2p.z*v.x*v.y*v.z*values[57] + 9*p.y*pow2p.z*pow2v.y*v.z*values[60] + p.y*p.z*pow3v.x*values[23] + 2*p.y*p.z*pow2v.x*v.y*values[26] + 2*p.y*p.z*pow2v.x*v.z*values[38] + 3*p.y*p.z*v.x*pow2v.y*values[29] + 4*p.y*p.z*v.x*v.y*v.z*values[41] + 3*p.y*p.z*v.x*pow2v.z*values[53] + 6*p.y*p.z*pow2v.y*v.z*values[44] + 6*p.y*p.z*v.y*pow2v.z*values[56] + p.y*pow3v.x*values[7] + 2*p.y*pow2v.x*v.y*values[10] + p.y*pow2v.x*v.z*values[22] + 3*p.y*v.x*pow2v.y*values[13] + 2*p.y*v.x*v.y*v.z*values[25] + p.y*v.x*pow2v.z*values[37] + 3*p.y*pow2v.y*v.z*values[28] + 2*p.y*v.y*pow2v.z*values[40] + p.y*pow3v.z*values[52] + pow3p.z*pow3v.x*values[51] + pow3p.z*pow2v.x*v.y*values[54] + pow3p.z*v.x*pow2v.y*values[57] + pow3p.z*pow3v.y*values[60] + pow2p.z*pow3v.x*values[35] + pow2p.z*pow2v.x*v.y*values[38] + 3*pow2p.z*pow2v.x*v.z*values[50] + pow2p.z*v.x*pow2v.y*values[41] + 3*pow2p.z*v.x*v.y*v.z*values[53] + pow2p.z*pow3v.y*values[44] + 3*pow2p.z*pow2v.y*v.z*values[56] + p.z*pow3v.x*values[19] + p.z*pow2v.x*v.y*values[22] + 2*p.z*pow2v.x*v.z*values[34] + p.z*v.x*pow2v.y*values[25] + 2*p.z*v.x*v.y*v.z*values[37] + 3*p.z*v.x*pow2v.z*values[49] + p.z*pow3v.y*values[28] + 2*p.z*pow2v.y*v.z*values[40] + 3*p.z*v.y*pow2v.z*values[52] + pow3v.x*values[3] + pow2v.x*v.y*values[6] + pow2v.x*v.z*values[18] + v.x*pow2v.y*values[9] + v.x*v.y*v.z*values[21] + v.x*pow2v.z*values[33] + pow3v.y*values[12] + pow2v.y*v.z*values[24] + v.y*pow2v.z*values[36] + pow3v.z*values[48];
    // eq[4] = 3*pow3p.x*pow2p.y*v.y*pow3v.z*values[63] + 9*pow3p.x*p.y*p.z*pow2v.y*pow2v.z*values[63] + 3*pow3p.x*p.y*pow2v.y*pow2v.z*values[47] + 2*pow3p.x*p.y*v.y*pow3v.z*values[59] + 3*pow3p.x*pow2p.z*pow3v.y*v.z*values[63] + 2*pow3p.x*p.z*pow3v.y*v.z*values[47] + 3*pow3p.x*p.z*pow2v.y*pow2v.z*values[59] + pow3p.x*pow3v.y*v.z*values[31] + pow3p.x*pow2v.y*pow2v.z*values[43] + pow3p.x*v.y*pow3v.z*values[55] + 3*pow2p.x*pow3p.y*v.x*pow3v.z*values[63] + 27*pow2p.x*pow2p.y*p.z*v.x*v.y*pow2v.z*values[63] + 9*pow2p.x*pow2p.y*v.x*v.y*pow2v.z*values[47] + 3*pow2p.x*pow2p.y*v.x*pow3v.z*values[59] + 3*pow2p.x*pow2p.y*v.y*pow3v.z*values[62] + 27*pow2p.x*p.y*pow2p.z*v.x*pow2v.y*v.z*values[63] + 18*pow2p.x*p.y*p.z*v.x*pow2v.y*v.z*values[47] + 18*pow2p.x*p.y*p.z*v.x*v.y*pow2v.z*values[59] + 9*pow2p.x*p.y*p.z*pow2v.y*pow2v.z*values[62] + 9*pow2p.x*p.y*v.x*pow2v.y*v.z*values[31] + 6*pow2p.x*p.y*v.x*v.y*pow2v.z*values[43] + 3*pow2p.x*p.y*v.x*pow3v.z*values[55] + 3*pow2p.x*p.y*pow2v.y*pow2v.z*values[46] + 2*pow2p.x*p.y*v.y*pow3v.z*values[58] + 3*pow2p.x*pow3p.z*v.x*pow3v.y*values[63] + 3*pow2p.x*pow2p.z*v.x*pow3v.y*values[47] + 9*pow2p.x*pow2p.z*v.x*pow2v.y*v.z*values[59] + 3*pow2p.x*pow2p.z*pow3v.y*v.z*values[62] + 3*pow2p.x*p.z*v.x*pow3v.y*values[31] + 6*pow2p.x*p.z*v.x*pow2v.y*v.z*values[43] + 9*pow2p.x*p.z*v.x*v.y*pow2v.z*values[55] + 2*pow2p.x*p.z*pow3v.y*v.z*values[46] + 3*pow2p.x*p.z*pow2v.y*pow2v.z*values[58] + 3*pow2p.x*v.x*pow3v.y*values[15] + 3*pow2p.x*v.x*pow2v.y*v.z*values[27] + 3*pow2p.x*v.x*v.y*pow2v.z*values[39] + 3*pow2p.x*v.x*pow3v.z*values[51] + pow2p.x*pow3v.y*v.z*values[30] + pow2p.x*pow2v.y*pow2v.z*values[42] + pow2p.x*v.y*pow3v.z*values[54] + 9*p.x*pow3p.y*p.z*pow2v.x*pow2v.z*values[63] + 3*p.x*pow3p.y*pow2v.x*pow2v.z*values[47] + 2*p.x*pow3p.y*v.x*pow3v.z*values[62] + 27*p.x*pow2p.y*pow2p.z*pow2v.x*v.y*v.z*values[63] + 18*p.x*pow2p.y*p.z*pow2v.x*v.y*v.z*values[47] + 9*p.x*pow2p.y*p.z*pow2v.x*pow2v.z*values[59] + 18*p.x*pow2p.y*p.z*v.x*v.y*pow2v.z*values[62] + 9*p.x*pow2p.y*pow2v.x*v.y*v.z*values[31] + 3*p.x*pow2p.y*pow2v.x*pow2v.z*values[43] + 6*p.x*pow2p.y*v.x*v.y*pow2v.z*values[46] + 2*p.x*pow2p.y*v.x*pow3v.z*values[58] + 3*p.x*pow2p.y*v.y*pow3v.z*values[61] + 9*p.x*p.y*pow3p.z*pow2v.x*pow2v.y*values[63] + 9*p.x*p.y*pow2p.z*pow2v.x*pow2v.y*values[47] + 18*p.x*p.y*pow2p.z*pow2v.x*v.y*v.z*values[59] + 18*p.x*p.y*pow2p.z*v.x*pow2v.y*v.z*values[62] + 9*p.x*p.y*p.z*pow2v.x*pow2v.y*values[31] + 12*p.x*p.y*p.z*pow2v.x*v.y*v.z*values[43] + 9*p.x*p.y*p.z*pow2v.x*pow2v.z*values[55] + 12*p.x*p.y*p.z*v.x*pow2v.y*v.z*values[46] + 12*p.x*p.y*p.z*v.x*v.y*pow2v.z*values[58] + 9*p.x*p.y*p.z*pow2v.y*pow2v.z*values[61] + 9*p.x*p.y*pow2v.x*pow2v.y*values[15] + 6*p.x*p.y*pow2v.x*v.y*v.z*values[27] + 3*p.x*p.y*pow2v.x*pow2v.z*values[39] + 6*p.x*p.y*v.x*pow2v.y*v.z*values[30] + 4*p.x*p.y*v.x*v.y*pow2v.z*values[42] + 2*p.x*p.y*v.x*pow3v.z*values[54] + 3*p.x*p.y*pow2v.y*pow2v.z*values[45] + 2*p.x*p.y*v.y*pow3v.z*values[57] + 3*p.x*pow3p.z*pow2v.x*pow2v.y*values[59] + 2*p.x*pow3p.z*v.x*pow3v.y*values[62] + 3*p.x*pow2p.z*pow2v.x*pow2v.y*values[43] + 9*p.x*pow2p.z*pow2v.x*v.y*v.z*values[55] + 2*p.x*pow2p.z*v.x*pow3v.y*values[46] + 6*p.x*pow2p.z*v.x*pow2v.y*v.z*values[58] + 3*p.x*pow2p.z*pow3v.y*v.z*values[61] + 3*p.x*p.z*pow2v.x*pow2v.y*values[27] + 6*p.x*p.z*pow2v.x*v.y*v.z*values[39] + 9*p.x*p.z*pow2v.x*pow2v.z*values[51] + 2*p.x*p.z*v.x*pow3v.y*values[30] + 4*p.x*p.z*v.x*pow2v.y*v.z*values[42] + 6*p.x*p.z*v.x*v.y*pow2v.z*values[54] + 2*p.x*p.z*pow3v.y*v.z*values[45] + 3*p.x*p.z*pow2v.y*pow2v.z*values[57] + 3*p.x*pow2v.x*pow2v.y*values[11] + 3*p.x*pow2v.x*v.y*v.z*values[23] + 3*p.x*pow2v.x*pow2v.z*values[35] + 2*p.x*v.x*pow3v.y*values[14] + 2*p.x*v.x*pow2v.y*v.z*values[26] + 2*p.x*v.x*v.y*pow2v.z*values[38] + 2*p.x*v.x*pow3v.z*values[50] + p.x*pow3v.y*v.z*values[29] + p.x*pow2v.y*pow2v.z*values[41] + p.x*v.y*pow3v.z*values[53] + 3*pow3p.y*pow2p.z*pow3v.x*v.z*values[63] + 2*pow3p.y*p.z*pow3v.x*v.z*values[47] + 3*pow3p.y*p.z*pow2v.x*pow2v.z*values[62] + pow3p.y*pow3v.x*v.z*values[31] + pow3p.y*pow2v.x*pow2v.z*values[46] + pow3p.y*v.x*pow3v.z*values[61] + 3*pow2p.y*pow3p.z*pow3v.x*v.y*values[63] + 3*pow2p.y*pow2p.z*pow3v.x*v.y*values[47] + 3*pow2p.y*pow2p.z*pow3v.x*v.z*values[59] + 9*pow2p.y*pow2p.z*pow2v.x*v.y*v.z*values[62] + 3*pow2p.y*p.z*pow3v.x*v.y*values[31] + 2*pow2p.y*p.z*pow3v.x*v.z*values[43] + 6*pow2p.y*p.z*pow2v.x*v.y*v.z*values[46] + 3*pow2p.y*p.z*pow2v.x*pow2v.z*values[58] + 9*pow2p.y*p.z*v.x*v.y*pow2v.z*values[61] + 3*pow2p.y*pow3v.x*v.y*values[15] + pow2p.y*pow3v.x*v.z*values[27] + 3*pow2p.y*pow2v.x*v.y*v.z*values[30] + pow2p.y*pow2v.x*pow2v.z*values[42] + 3*pow2p.y*v.x*v.y*pow2v.z*values[45] + pow2p.y*v.x*pow3v.z*values[57] + 3*pow2p.y*v.y*pow3v.z*values[60] + 2*p.y*pow3p.z*pow3v.x*v.y*values[59] + 3*p.y*pow3p.z*pow2v.x*pow2v.y*values[62] + 2*p.y*pow2p.z*pow3v.x*v.y*values[43] + 3*p.y*pow2p.z*pow3v.x*v.z*values[55] + 3*p.y*pow2p.z*pow2v.x*pow2v.y*values[46] + 6*p.y*pow2p.z*pow2v.x*v.y*v.z*values[58] + 9*p.y*pow2p.z*v.x*pow2v.y*v.z*values[61] + 2*p.y*p.z*pow3v.x*v.y*values[27] + 2*p.y*p.z*pow3v.x*v.z*values[39] + 3*p.y*p.z*pow2v.x*pow2v.y*values[30] + 4*p.y*p.z*pow2v.x*v.y*v.z*values[42] + 3*p.y*p.z*pow2v.x*pow2v.z*values[54] + 6*p.y*p.z*v.x*pow2v.y*v.z*values[45] + 6*p.y*p.z*v.x*v.y*pow2v.z*values[57] + 9*p.y*p.z*pow2v.y*pow2v.z*values[60] + 2*p.y*pow3v.x*v.y*values[11] + p.y*pow3v.x*v.z*values[23] + 3*p.y*pow2v.x*pow2v.y*values[14] + 2*p.y*pow2v.x*v.y*v.z*values[26] + p.y*pow2v.x*pow2v.z*values[38] + 3*p.y*v.x*pow2v.y*v.z*values[29] + 2*p.y*v.x*v.y*pow2v.z*values[41] + p.y*v.x*pow3v.z*values[53] + 3*p.y*pow2v.y*pow2v.z*values[44] + 2*p.y*v.y*pow3v.z*values[56] + pow3p.z*pow3v.x*v.y*values[55] + pow3p.z*pow2v.x*pow2v.y*values[58] + pow3p.z*v.x*pow3v.y*values[61] + pow2p.z*pow3v.x*v.y*values[39] + 3*pow2p.z*pow3v.x*v.z*values[51] + pow2p.z*pow2v.x*pow2v.y*values[42] + 3*pow2p.z*pow2v.x*v.y*v.z*values[54] + pow2p.z*v.x*pow3v.y*values[45] + 3*pow2p.z*v.x*pow2v.y*v.z*values[57] + 3*pow2p.z*pow3v.y*v.z*values[60] + p.z*pow3v.x*v.y*values[23] + 2*p.z*pow3v.x*v.z*values[35] + p.z*pow2v.x*pow2v.y*values[26] + 2*p.z*pow2v.x*v.y*v.z*values[38] + 3*p.z*pow2v.x*pow2v.z*values[50] + p.z*v.x*pow3v.y*values[29] + 2*p.z*v.x*pow2v.y*v.z*values[41] + 3*p.z*v.x*v.y*pow2v.z*values[53] + 2*p.z*pow3v.y*v.z*values[44] + 3*p.z*pow2v.y*pow2v.z*values[56] + pow3v.x*v.y*values[7] + pow3v.x*v.z*values[19] + pow2v.x*pow2v.y*values[10] + pow2v.x*v.y*v.z*values[22] + pow2v.x*pow2v.z*values[34] + v.x*pow3v.y*values[13] + v.x*pow2v.y*v.z*values[25] + v.x*v.y*pow2v.z*values[37] + v.x*pow3v.z*values[49] + pow3v.y*v.z*values[28] + pow2v.y*pow2v.z*values[40] + v.y*pow3v.z*values[52];
    // eq[5] = 3*pow3p.x*p.y*pow2v.y*pow3v.z*values[63] + 3*pow3p.x*p.z*pow3v.y*pow2v.z*values[63] + pow3p.x*pow3v.y*pow2v.z*values[47] + pow3p.x*pow2v.y*pow3v.z*values[59] + 9*pow2p.x*pow2p.y*v.x*v.y*pow3v.z*values[63] + 27*pow2p.x*p.y*p.z*v.x*pow2v.y*pow2v.z*values[63] + 9*pow2p.x*p.y*v.x*pow2v.y*pow2v.z*values[47] + 6*pow2p.x*p.y*v.x*v.y*pow3v.z*values[59] + 3*pow2p.x*p.y*pow2v.y*pow3v.z*values[62] + 9*pow2p.x*pow2p.z*v.x*pow3v.y*v.z*values[63] + 6*pow2p.x*p.z*v.x*pow3v.y*v.z*values[47] + 9*pow2p.x*p.z*v.x*pow2v.y*pow2v.z*values[59] + 3*pow2p.x*p.z*pow3v.y*pow2v.z*values[62] + 3*pow2p.x*v.x*pow3v.y*v.z*values[31] + 3*pow2p.x*v.x*pow2v.y*pow2v.z*values[43] + 3*pow2p.x*v.x*v.y*pow3v.z*values[55] + pow2p.x*pow3v.y*pow2v.z*values[46] + pow2p.x*pow2v.y*pow3v.z*values[58] + 3*p.x*pow3p.y*pow2v.x*pow3v.z*values[63] + 27*p.x*pow2p.y*p.z*pow2v.x*v.y*pow2v.z*values[63] + 9*p.x*pow2p.y*pow2v.x*v.y*pow2v.z*values[47] + 3*p.x*pow2p.y*pow2v.x*pow3v.z*values[59] + 6*p.x*pow2p.y*v.x*v.y*pow3v.z*values[62] + 27*p.x*p.y*pow2p.z*pow2v.x*pow2v.y*v.z*values[63] + 18*p.x*p.y*p.z*pow2v.x*pow2v.y*v.z*values[47] + 18*p.x*p.y*p.z*pow2v.x*v.y*pow2v.z*values[59] + 18*p.x*p.y*p.z*v.x*pow2v.y*pow2v.z*values[62] + 9*p.x*p.y*pow2v.x*pow2v.y*v.z*values[31] + 6*p.x*p.y*pow2v.x*v.y*pow2v.z*values[43] + 3*p.x*p.y*pow2v.x*pow3v.z*values[55] + 6*p.x*p.y*v.x*pow2v.y*pow2v.z*values[46] + 4*p.x*p.y*v.x*v.y*pow3v.z*values[58] + 3*p.x*p.y*pow2v.y*pow3v.z*values[61] + 3*p.x*pow3p.z*pow2v.x*pow3v.y*values[63] + 3*p.x*pow2p.z*pow2v.x*pow3v.y*values[47] + 9*p.x*pow2p.z*pow2v.x*pow2v.y*v.z*values[59] + 6*p.x*pow2p.z*v.x*pow3v.y*v.z*values[62] + 3*p.x*p.z*pow2v.x*pow3v.y*values[31] + 6*p.x*p.z*pow2v.x*pow2v.y*v.z*values[43] + 9*p.x*p.z*pow2v.x*v.y*pow2v.z*values[55] + 4*p.x*p.z*v.x*pow3v.y*v.z*values[46] + 6*p.x*p.z*v.x*pow2v.y*pow2v.z*values[58] + 3*p.x*p.z*pow3v.y*pow2v.z*values[61] + 3*p.x*pow2v.x*pow3v.y*values[15] + 3*p.x*pow2v.x*pow2v.y*v.z*values[27] + 3*p.x*pow2v.x*v.y*pow2v.z*values[39] + 3*p.x*pow2v.x*pow3v.z*values[51] + 2*p.x*v.x*pow3v.y*v.z*values[30] + 2*p.x*v.x*pow2v.y*pow2v.z*values[42] + 2*p.x*v.x*v.y*pow3v.z*values[54] + p.x*pow3v.y*pow2v.z*values[45] + p.x*pow2v.y*pow3v.z*values[57] + 3*pow3p.y*p.z*pow3v.x*pow2v.z*values[63] + pow3p.y*pow3v.x*pow2v.z*values[47] + pow3p.y*pow2v.x*pow3v.z*values[62] + 9*pow2p.y*pow2p.z*pow3v.x*v.y*v.z*values[63] + 6*pow2p.y*p.z*pow3v.x*v.y*v.z*values[47] + 3*pow2p.y*p.z*pow3v.x*pow2v.z*values[59] + 9*pow2p.y*p.z*pow2v.x*v.y*pow2v.z*values[62] + 3*pow2p.y*pow3v.x*v.y*v.z*values[31] + pow2p.y*pow3v.x*pow2v.z*values[43] + 3*pow2p.y*pow2v.x*v.y*pow2v.z*values[46] + pow2p.y*pow2v.x*pow3v.z*values[58] + 3*pow2p.y*v.x*v.y*pow3v.z*values[61] + 3*p.y*pow3p.z*pow3v.x*pow2v.y*values[63] + 3*p.y*pow2p.z*pow3v.x*pow2v.y*values[47] + 6*p.y*pow2p.z*pow3v.x*v.y*v.z*values[59] + 9*p.y*pow2p.z*pow2v.x*pow2v.y*v.z*values[62] + 3*p.y*p.z*pow3v.x*pow2v.y*values[31] + 4*p.y*p.z*pow3v.x*v.y*v.z*values[43] + 3*p.y*p.z*pow3v.x*pow2v.z*values[55] + 6*p.y*p.z*pow2v.x*pow2v.y*v.z*values[46] + 6*p.y*p.z*pow2v.x*v.y*pow2v.z*values[58] + 9*p.y*p.z*v.x*pow2v.y*pow2v.z*values[61] + 3*p.y*pow3v.x*pow2v.y*values[15] + 2*p.y*pow3v.x*v.y*v.z*values[27] + p.y*pow3v.x*pow2v.z*values[39] + 3*p.y*pow2v.x*pow2v.y*v.z*values[30] + 2*p.y*pow2v.x*v.y*pow2v.z*values[42] + p.y*pow2v.x*pow3v.z*values[54] + 3*p.y*v.x*pow2v.y*pow2v.z*values[45] + 2*p.y*v.x*v.y*pow3v.z*values[57] + 3*p.y*pow2v.y*pow3v.z*values[60] + pow3p.z*pow3v.x*pow2v.y*values[59] + pow3p.z*pow2v.x*pow3v.y*values[62] + pow2p.z*pow3v.x*pow2v.y*values[43] + 3*pow2p.z*pow3v.x*v.y*v.z*values[55] + pow2p.z*pow2v.x*pow3v.y*values[46] + 3*pow2p.z*pow2v.x*pow2v.y*v.z*values[58] + 3*pow2p.z*v.x*pow3v.y*v.z*values[61] + p.z*pow3v.x*pow2v.y*values[27] + 2*p.z*pow3v.x*v.y*v.z*values[39] + 3*p.z*pow3v.x*pow2v.z*values[51] + p.z*pow2v.x*pow3v.y*values[30] + 2*p.z*pow2v.x*pow2v.y*v.z*values[42] + 3*p.z*pow2v.x*v.y*pow2v.z*values[54] + 2*p.z*v.x*pow3v.y*v.z*values[45] + 3*p.z*v.x*pow2v.y*pow2v.z*values[57] + 3*p.z*pow3v.y*pow2v.z*values[60] + pow3v.x*pow2v.y*values[11] + pow3v.x*v.y*v.z*values[23] + pow3v.x*pow2v.z*values[35] + pow2v.x*pow3v.y*values[14] + pow2v.x*pow2v.y*v.z*values[26] + pow2v.x*v.y*pow2v.z*values[38] + pow2v.x*pow3v.z*values[50] + v.x*pow3v.y*v.z*values[29] + v.x*pow2v.y*pow2v.z*values[41] + v.x*v.y*pow3v.z*values[53] + pow3v.y*pow2v.z*values[44] + pow2v.y*pow3v.z*values[56];
    // eq[6] = pow3p.x*pow3v.y*pow3v.z*values[63] + 9*pow2p.x*p.y*v.x*pow2v.y*pow3v.z*values[63] + 9*pow2p.x*p.z*v.x*pow3v.y*pow2v.z*values[63] + 3*pow2p.x*v.x*pow3v.y*pow2v.z*values[47] + 3*pow2p.x*v.x*pow2v.y*pow3v.z*values[59] + pow2p.x*pow3v.y*pow3v.z*values[62] + 9*p.x*pow2p.y*pow2v.x*v.y*pow3v.z*values[63] + 27*p.x*p.y*p.z*pow2v.x*pow2v.y*pow2v.z*values[63] + 9*p.x*p.y*pow2v.x*pow2v.y*pow2v.z*values[47] + 6*p.x*p.y*pow2v.x*v.y*pow3v.z*values[59] + 6*p.x*p.y*v.x*pow2v.y*pow3v.z*values[62] + 9*p.x*pow2p.z*pow2v.x*pow3v.y*v.z*values[63] + 6*p.x*p.z*pow2v.x*pow3v.y*v.z*values[47] + 9*p.x*p.z*pow2v.x*pow2v.y*pow2v.z*values[59] + 6*p.x*p.z*v.x*pow3v.y*pow2v.z*values[62] + 3*p.x*pow2v.x*pow3v.y*v.z*values[31] + 3*p.x*pow2v.x*pow2v.y*pow2v.z*values[43] + 3*p.x*pow2v.x*v.y*pow3v.z*values[55] + 2*p.x*v.x*pow3v.y*pow2v.z*values[46] + 2*p.x*v.x*pow2v.y*pow3v.z*values[58] + p.x*pow3v.y*pow3v.z*values[61] + pow3p.y*pow3v.x*pow3v.z*values[63] + 9*pow2p.y*p.z*pow3v.x*v.y*pow2v.z*values[63] + 3*pow2p.y*pow3v.x*v.y*pow2v.z*values[47] + pow2p.y*pow3v.x*pow3v.z*values[59] + 3*pow2p.y*pow2v.x*v.y*pow3v.z*values[62] + 9*p.y*pow2p.z*pow3v.x*pow2v.y*v.z*values[63] + 6*p.y*p.z*pow3v.x*pow2v.y*v.z*values[47] + 6*p.y*p.z*pow3v.x*v.y*pow2v.z*values[59] + 9*p.y*p.z*pow2v.x*pow2v.y*pow2v.z*values[62] + 3*p.y*pow3v.x*pow2v.y*v.z*values[31] + 2*p.y*pow3v.x*v.y*pow2v.z*values[43] + p.y*pow3v.x*pow3v.z*values[55] + 3*p.y*pow2v.x*pow2v.y*pow2v.z*values[46] + 2*p.y*pow2v.x*v.y*pow3v.z*values[58] + 3*p.y*v.x*pow2v.y*pow3v.z*values[61] + pow3p.z*pow3v.x*pow3v.y*values[63] + pow2p.z*pow3v.x*pow3v.y*values[47] + 3*pow2p.z*pow3v.x*pow2v.y*v.z*values[59] + 3*pow2p.z*pow2v.x*pow3v.y*v.z*values[62] + p.z*pow3v.x*pow3v.y*values[31] + 2*p.z*pow3v.x*pow2v.y*v.z*values[43] + 3*p.z*pow3v.x*v.y*pow2v.z*values[55] + 2*p.z*pow2v.x*pow3v.y*v.z*values[46] + 3*p.z*pow2v.x*pow2v.y*pow2v.z*values[58] + 3*p.z*v.x*pow3v.y*pow2v.z*values[61] + pow3v.x*pow3v.y*values[15] + pow3v.x*pow2v.y*v.z*values[27] + pow3v.x*v.y*pow2v.z*values[39] + pow3v.x*pow3v.z*values[51] + pow2v.x*pow3v.y*v.z*values[30] + pow2v.x*pow2v.y*pow2v.z*values[42] + pow2v.x*v.y*pow3v.z*values[54] + v.x*pow3v.y*pow2v.z*values[45] + v.x*pow2v.y*pow3v.z*values[57] + pow3v.y*pow3v.z*values[60];
    // eq[7] = 3*pow2p.x*v.x*pow3v.y*pow3v.z*values[63] + 9*p.x*p.y*pow2v.x*pow2v.y*pow3v.z*values[63] + 9*p.x*p.z*pow2v.x*pow3v.y*pow2v.z*values[63] + 3*p.x*pow2v.x*pow3v.y*pow2v.z*values[47] + 3*p.x*pow2v.x*pow2v.y*pow3v.z*values[59] + 2*p.x*v.x*pow3v.y*pow3v.z*values[62] + 3*pow2p.y*pow3v.x*v.y*pow3v.z*values[63] + 9*p.y*p.z*pow3v.x*pow2v.y*pow2v.z*values[63] + 3*p.y*pow3v.x*pow2v.y*pow2v.z*values[47] + 2*p.y*pow3v.x*v.y*pow3v.z*values[59] + 3*p.y*pow2v.x*pow2v.y*pow3v.z*values[62] + 3*pow2p.z*pow3v.x*pow3v.y*v.z*values[63] + 2*p.z*pow3v.x*pow3v.y*v.z*values[47] + 3*p.z*pow3v.x*pow2v.y*pow2v.z*values[59] + 3*p.z*pow2v.x*pow3v.y*pow2v.z*values[62] + pow3v.x*pow3v.y*v.z*values[31] + pow3v.x*pow2v.y*pow2v.z*values[43] + pow3v.x*v.y*pow3v.z*values[55] + pow2v.x*pow3v.y*pow2v.z*values[46] + pow2v.x*pow2v.y*pow3v.z*values[58] + v.x*pow3v.y*pow3v.z*values[61];
    // eq[8] = 3*p.x*pow2v.x*pow3v.y*pow3v.z*values[63] + 3*p.y*pow3v.x*pow2v.y*pow3v.z*values[63] + 3*p.z*pow3v.x*pow3v.y*pow2v.z*values[63] + pow3v.x*pow3v.y*pow2v.z*values[47] + pow3v.x*pow2v.y*pow3v.z*values[59] + pow2v.x*pow3v.y*pow3v.z*values[62];
    // eq[9] = pow3v.x*pow3v.y*pow3v.z*values[63];

    // vec4 data = octreeValues[vIndex + 0];
    // tmp = vec4(v.x, v.y, v.z, 0.0);
    // tmp = tmp * tmp * tmp;
    // eq[9] = tmp.x * tmp.y * tmp.z * data.x;

    // t[2] = data.y * vec4(p.z, v.z, 0.0, 0.0); //x3y3z2
    // tmp = t[2]; tmp.x += data.z; //x3y3z
    // t[2] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    // tmp = t[2]; tmp.x += data.w; //x3y3
    // t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y;

    vec4[6] t;
    t[0] = vec4(0.0); t[1] = vec4(0.0); //t[2] = vec4(0.0); t[3] = vec4(0.0);
    float[10] eq;
    eq[8] = 0.0; eq[9] = 0.0;
    vec4 tmp, tmp1;

    // Start Block x3
    vec4 data = octreeValues[vIndex + 0];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x3y3z3
    tmp = t[4]; tmp.x += data.y; //x3y3z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x3y3z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[4]; tmp.x += data.w; // x3y3
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = vec4(tmp.w, 0.0, 0.0, 0.0) * v.y;

    data = octreeValues[vIndex + 1];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x3y2z3
    tmp = t[4]; tmp.x += data.y; //x3y2z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x3y2z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; // x3y2
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 2];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x3yz3
    tmp = t[4]; tmp.x += data.y; //x3yz2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x3yz
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; // x3y
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 3];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x3z3
    tmp = t[4]; tmp.x += data.y; //x3z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x3z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    // End Block x3

    tmp = t[0] + t[2] + t[4]; tmp.x += data.w; tmp1 = t[1] + t[3];// x3
    t[0] = tmp * p.x + vec4(0.0, tmp.xyz) * v.x; t[1] = tmp1 * p.x + vec4(tmp.w, tmp1.xyz) * v.x; //eq[8] = eq[8] * p.x + tmp1.w * v.x;

    // Start Block x2
    data = octreeValues[vIndex + 4];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x2y3z3
    tmp = t[4]; tmp.x += data.y; //x2y3z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x2y3z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[4]; tmp.x += data.w; // x2y3
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = vec4(tmp.w, 0.0, 0.0, 0.0) * v.y;

    data = octreeValues[vIndex + 5];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x2y2z3
    tmp = t[4]; tmp.x += data.y; //x2y2z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x2y2z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; // x2y2
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 6];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x2yz3
    tmp = t[4]; tmp.x += data.y; //x2yz2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x2yz
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; // x2y
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 7];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //x2z3
    tmp = t[4]; tmp.x += data.y; //x2z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //x2z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    // End Block x2

    tmp = t[0] + t[2] + t[4]; tmp.x += data.w; tmp1 = t[1] + t[3];// x2
    t[0] = tmp * p.x + vec4(0.0, tmp.xyz) * v.x; t[1] = tmp1 * p.x + vec4(tmp.w, tmp1.xyz) * v.x; eq[8] = eq[8] * p.x + tmp1.w * v.x;

    // Start Block x
    data = octreeValues[vIndex + 8];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //xy3z3
    tmp = t[4]; tmp.x += data.y; //xy3z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //xy3z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[4]; tmp.x += data.w; //xy3
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = vec4(tmp.w, 0.0, 0.0, 0.0) * v.y;

    data = octreeValues[vIndex + 9];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //xy2z3
    tmp = t[4]; tmp.x += data.y; //xy2z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //xy2z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; // xy2
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 10];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //xyz3
    tmp = t[4]; tmp.x += data.y; //xyz2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //xyz
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; // xy
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 11];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //xz3
    tmp = t[4]; tmp.x += data.y; //xz2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //xz
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    // End Block x

    tmp = t[0] + t[2] + t[4]; tmp.x += data.w; tmp1 = t[1] + t[3]; // x
    t[0] = tmp * p.x + vec4(0.0, tmp.xyz) * v.x; t[1] = tmp1 * p.x + vec4(tmp.w, tmp1.xyz) * v.x; eq[9] = eq[8] * v.x; eq[8] = eq[8] * p.x + tmp1.w * v.x;

    // Start Block -
    data = octreeValues[vIndex + 12];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //y3z3
    tmp = t[4]; tmp.x += data.y; //y3z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //y3z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[4]; tmp.x += data.w; //y3
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = vec4(tmp.w, 0.0, 0.0, 0.0) * v.y;

    data = octreeValues[vIndex + 13];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //y2z3
    tmp = t[4]; tmp.x += data.y; //y2z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //y2z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; // y2
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 14];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //yz3
    tmp = t[4]; tmp.x += data.y; //yz2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //yz
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    tmp = t[2] + t[4]; tmp.x += data.w; //y
    t[2] = tmp * p.y + vec4(0.0, tmp.xyz) * v.y; t[3] = t[3] * p.y + vec4(tmp.w, t[3].xyz) * v.y;

    data = octreeValues[vIndex + 15];
    t[4] = data.x * vec4(p.z, v.z, 0.0, 0.0); //z3
    tmp = t[4]; tmp.x += data.y; //z2
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;
    tmp = t[4]; tmp.x += data.z; //z
    t[4] = tmp * p.z + vec4(0.0, tmp.xyz) * v.z;

    // End Block -

    t[0] += t[2] + t[4] + vec4(data.w, 0.0, 0.0, 0.0);
    t[1] += t[3];

    eq[0] = t[0].x;
    eq[1] = t[0].y;
    eq[2] = t[0].z;
    eq[3] = t[0].w;

    eq[4] = t[1].x;
    eq[5] = t[1].y;
    eq[6] = t[1].z;
    eq[7] = t[1].w;

#if defined(OCTREE_TRAVERSAL_AND_SOLVER) || defined(SPHERE_MARCHING_SOLVER)
    float[MAX_DEGREE+1] results;
    find_roots(results, eq, leaf_t_in, leaf_t_out);
    for (int i = 0; i < MAX_DEGREE; ++i)
    {
        vec3 intersectionPoint = p + v * results[i];
        if (isInsideNode(intersectionPoint, vec3(0.0), vec3(1.0))) {
            result = o + dir * results[i] * sfactor;
            return true;
        }
    }

    return false;
#endif

#if defined(OCTREE_TRAVERSAL_AND_SH) || defined(SPHERE_MARCHING)

    // Normalize ray
    float td=leaf_t_in;
    
    float a = eq[2] + dot(min(vec4(0.0), vec4(eq[9], eq[8], eq[7], eq[6])) + min(vec4(0.0), vec4(eq[5], eq[4], eq[3], 0.0)), vec4(1.0));
    float discriminant = eq[1] * eq[1] - 4.0 * eq[0] * a;
    if (discriminant >= 0.0) {
        float sqrt_discriminant = sqrt(discriminant);
        float scaled_root = eq[1] + ((eq[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));
        float root_0 = clamp(-2.0 * eq[0] / scaled_root, leaf_t_in-1.0, leaf_t_out + 1.0);
        float root_1 = clamp(-0.5 * scaled_root / a, leaf_t_in-1.0, leaf_t_out + 1.0);

        float r1 = min(root_0, root_1);
        float r2 = max(root_0, root_1);
        if(eq[0] > 0.0 && 
           (r1 < leaf_t_in || r1 > leaf_t_out) &&
           (r2 < leaf_t_in || r2 > leaf_t_out))
        {
            return false;
        }

        td = max(leaf_t_in, (eq[0] > 0.0 && r1 < leaf_t_in) ? r2 : r1);
    } else return false;

    float lastDistance = 1e8;
    uint it = 0;
    while (lastDistance > localEpsilon && td < leaf_t_out && it < 1280)
    {
        lastDistance = ((((((((eq[9] * td + eq[8]) * td + eq[7]) * td + eq[6]) * td + eq[5]) * td  + eq[4]) * td + eq[3]) * td + eq[2]) * td + eq[1]) * td + eq[0];
        lastDistance = distanceScale * lastDistance;
        float dist = max(lastDistance, 0.0);
        td += dist / sfactor;
        it += 1;
    }

    result = o + dir * td * sfactor;
    return lastDistance < localEpsilon;


    // float lastDistance = 1e8;
    // uint it = 0;
    // while (lastDistance > localEpsilon && td < leaf_t_out && it < 1280)
    // {
    //     lastDistance = evalNode(vIndex, p + v * td);
    //     lastDistance = distanceScale * lastDistance;
    //     float dist = max(lastDistance, 0.0);
    //     td += dist / sfactor;
    //     it += 1;
    // }

    // result = o + dir * td * sfactor;
    // return lastDistance < localEpsilon;

#endif
#endif

}
#endif

// #if defined(SPHERE_MARCHING)
// // Raycast using ray marching
// bool sphereMarching(vec3 startPos, vec3 dir, float tmax, out vec3 resultPos)
// {
//     float accDistance = 0.0;
//     vec3 pos = startPos;
//     float lastDistance = 1e8;
//     uint it = 0;
//     while (lastDistance > epsilon && accDistance < tmax && it < maxIterations)
//     {
//         resultPos = pos;
//         lastDistance = map(pos);
//         float dist = max(lastDistance, 0.0);
//         accDistance += dist;
//         pos += dir * dist;
//         it += 1;
//     }
//     return !(lastDistance > epsilon);
// }
// #endif

#if defined(SPHERE_MARCHING) || defined(SPHERE_MARCHING_SOLVER)
// #if defined(SPHERE_MARCHING_SOLVER)
#define DIST_SUB 0.95
bool sphereMarching(vec3 startPos, vec3 dir, float tmax, out vec3 resultPos, out uint fIt)
{
    fIt = 0;
    vec3 dir_inv = vec3(1/dir.x, 1/dir.y, 1/dir.z);
    float t_in;
    float t_out;
    bool intersect = raySlabIntersection(vec3(0), vec3(1), startPos, dir_inv, t_in, t_out);
    if (t_out < 0) return false;
    //intersect bounding box first, if no intersection return false automatically
    if (!intersect) return false;

    float accDistance = max(0, t_in) + 1e-4;
    vec3 pos = startPos + accDistance * dir;
    float lastDistance = 1e8;
    uint it = 0;

    vec3 leafPos;
    float leafSize;
    vec3 fracPart;

    float t_end = min(t_out, tmax);

    while (lastDistance > epsilon * accDistance && accDistance < t_end && it < maxIterations)
    {
        resultPos = pos;

        uint leafNode = getLeaf(pos, leafPos, leafSize, fracPart);
        if(bool(leafNode & isMarkedMask))
        {
            vec3 solverPos;
            if(solvePolynomialEquation(pos - dir * 1e-4, dir, accDistance, leafNode, leafPos, leafSize, solverPos))
            {
                fIt = it;
                resultPos = solverPos;
                return true;
            }

            // float t_int = rayLeafIntersection(leafPos + leafSize, leafPos, pos, 1.0/dir);
            // lastDistance = t_int + 1e-4;
        }
        // else
        // {
            if(bool(leafNode & isLeafMask))
            {
                lastDistance = DIST_SUB * distanceScale * evalNode(leafNode & childrenIndexMask, fracPart);
                float t_int = rayLeafIntersection(leafPos + leafSize, leafPos, pos, 1.0/dir);
                if(lastDistance > 0) lastDistance = max(lastDistance, t_int + 1e-4);
            }
            else
            {
                vec3 q = abs(pos - vec3(0.5)) - 0.5;
                lastDistance = distanceScale * (length(max(q, vec3(0.0)))/distanceScale + minBorderValue);
            }
        // }

        float dist = max(lastDistance, 0.0);
        accDistance += dist;
        pos += dir * dist;
        it += 1;
    }
    fIt = it;
    return lastDistance < epsilon * accDistance;
}
#endif

#if defined(OCTREE_TRAVERSAL_AND_SH) || defined(OCTREE_TRAVERSAL_AND_SOLVER)
bool octreeRayCast(vec3 o, vec3 dir, float far, out vec3 result, out uint it)
{
    it = 0;
    vec3 dir_inv = vec3(1/dir.x, 1/dir.y, 1/dir.z);
    float t_in;
    float t_out;
    bool intersect = raySlabIntersection(vec3(0), vec3(1), o, dir_inv, t_in, t_out);
    if (t_out < 0) return false;
    //intersect bounding box first, if no intersection return false automatically
    if (!intersect) return false;
    
    //works until here
    float t_end = min(t_out, far);

    vec3 leafPos;
    float leafSize;
    vec3 fracPart;

    float t = max(0, t_in) + 1e-4;

    while (t >= 0 && t <= t_end)
    {
        // Get leaf
        uint leafNode = getLeaf(o + dir * t, leafPos, leafSize, fracPart); //problem is here maybe?

        vec3 leafBBmax = leafPos + leafSize;
        vec3 leafBBmin = leafPos;
        
        float t_int = rayLeafIntersection(leafBBmax, leafBBmin, o + dir * t, dir_inv);

        if (bool(leafNode & isMarkedMask)) // Is a leaf node
        {
            if(solvePolynomialEquation(o + dir * (t - 1e-4), dir, t, leafNode, leafPos, leafSize, result, it)) return true;
        }

        t += t_int + 1e-4; // Ensure to move to the next node
        // it++;
    }

    return false;    
}
#endif

bool raycast(vec3 ro, vec3 rd, float far)
{
    vec3 hitPoint;
    uint it;
    #if defined(SPHERE_MARCHING) || defined(SPHERE_MARCHING_SOLVER)
    return sphereMarching(ro, rd, far, hitPoint, it);
    #endif
    #if defined(OCTREE_TRAVERSAL_AND_SH) || defined(OCTREE_TRAVERSAL_AND_SOLVER)
    return octreeRayCast(ro, rd, far, hitPoint, it);
    #endif
}

//New main
void main()
{
    //Get pixel coord
    uvec2 pCoord = gl_GlobalInvocationID.xy;
    vec3 pixelPos = vec3((vec2(pCoord) + vec2(0.5)) * pixelToView - nearPlaneHalfSize, -nearAndFarPlane.x);

    //Get world position and direction
    vec3 worldPos = vec3(invViewModelMatrix * vec4(vec3(0.0), 1.0));
    vec3 worldDir = normalize(vec3(invViewModelMatrix * vec4(pixelPos, 1.0)) - worldPos);

    //Background colour
    vec3 outColor = vec3(1.0);
    uint it = 0;

    vec3 hitPoint;
    #if defined(SPHERE_MARCHING) || defined(SPHERE_MARCHING_SOLVER)
    if(sphereMarching(worldPos, worldDir, nearAndFarPlane.y, hitPoint, it))
    #endif
    #if defined(OCTREE_TRAVERSAL_AND_SH) || defined(OCTREE_TRAVERSAL_AND_SOLVER)
    if(octreeRayCast(worldPos, worldDir, nearAndFarPlane.y, hitPoint, it))
    #endif
    {
        outColor = mapColor(hitPoint, worldPos);
    }

    outColor = vec3(it/255.0);

    //Store the rendered image to output texture to later display in a quad
    imageStore(outputTexture, ivec2(pCoord), vec4(outColor, 1.0));
}